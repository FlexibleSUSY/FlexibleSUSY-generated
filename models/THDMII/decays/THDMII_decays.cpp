// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================


/**
 * @file THDMII_decays.cpp
 * @brief implementation of particle decays in the THDMII
 *
 * Contains the definition of THDMII decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated with FlexibleSUSY 2.6.1 and SARAH 4.14.5 .
 */

#include <cmath>

#include <boost/range/algorithm.hpp>
#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
#define BOOST_MPL_LIMIT_LIST_SIZE 50
#include <boost/mpl/for_each.hpp>
#include <boost/mpl/int.hpp>
#include <boost/mpl/at.hpp>
#include <boost/mpl/list.hpp>

#include "THDMII_decays.hpp"
#include "THDMII_info.hpp"
#include "decays/one_loop_decay_diagrams.hpp"
#include "concatenate.hpp"
#include "decays/decay_functions.hpp"
#include "dilog.hpp"
#include "trilog.hpp"
#include "Li4.hpp"
#include "config.h"
#include "thread_pool.hpp"
#include "wrappers.hpp"
#include "standard_model.hpp"
#include <gsl/gsl_monte_miser.h>

namespace flexiblesusy {

#define CLASSNAME THDMII_decays
#define PHYSICAL(parameter) model.get_physical().parameter

using namespace THDMII_cxx_diagrams;
using namespace THDMII_cxx_diagrams::fields;
namespace info = THDMII_info;
using namespace std::complex_literals;

const THDMII_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

const FlexibleDecay_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
try {
#ifdef ENABLE_THREADS
   Thread_pool tp(std::min(std::thread::hardware_concurrency(), 3u));

   tp.run_task([this] () { calculate_hh_decays(); });
   tp.run_task([this] () { calculate_Hm_decays(); });
   tp.run_task([this] () { calculate_Ah_decays(); });

#else
   calculate_hh_decays();
   calculate_Hm_decays();
   calculate_Ah_decays();

#endif
}
catch (std::exception& e) {
   problems.add_error(e.what());
}
}

double get_alphas(context_base const&  context)
{
   return Sqr(context.model.get_g3())/(4.*Pi);
}

double get_alpha(context_base const&  context)
{
   return Sqr(unit_charge(context))/(4.*Pi);
}

/* 1-loop BSM amplitudes
 *
 * Notes:
 *    - Since FS removes a factor of i from every vertex we reintroduce it
 *      calls to one loop amplitudes
 */

// hh -> {hh, hh}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, hh, hh>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<hh>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, hh, Ah>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_1, idx_2);
   const auto vertex =  Vertex<Ah, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Ah, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Ah, Ah>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Ah>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Ah, Ah, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Hm, conj[Hm]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Hm, typename conj<Hm>::type>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::Hm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Hm>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Hm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Hm, typename conj<Hm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VP>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VP>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Hm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g2n12_VV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.
                     value3(), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g10n30_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {hh, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, VZ, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Hm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hm, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWm], gWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Ah, typename conj<Hm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g10n40_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], Ah
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], Ah
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], Ah
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, Ah
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, Ah
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], Ah
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], VZ
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, Ah
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, typename conj<Hm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, VZ
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], Ah
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g10n50_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZ>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {conj[Hm], VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, typename conj<Hm>::type, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::Hm>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<typename conj<Hm>::type>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, Hm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {Hm, conj[VWm]}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Hm, typename conj<VWm>::type>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Hm>(idx_2);
   result.m_vector = context.physical_mass<typename conj<VWm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, typename conj<Hm>::type, VWm>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {VG, VG}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VG, VG>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VG >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VG >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VG>(idx_2);
   result.m_vector_2 = context.physical_mass<VG>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VP}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VP>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value3(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value2(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Hm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g2n14_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value3
                     (), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value3(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hm, conj[Hm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g10n40_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {VZ, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VZ, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, VZ, VZ>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {conj[VWm], VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, typename conj<VWm>::type, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<typename conj<VWm>::type>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, typename conj<VWm>::type, VWm>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {bar[Fv], Fv}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fv>::type, Fv>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fv >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fv>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[Hm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[VWm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g3n3_FFV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, VZ, Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g6n6_VVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hm>::type>;
      using vertexId3 = Vertex<hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<Hm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g4n4_SVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hm>::type>;
      using vertexId3 = Vertex<hh, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g5n5_VSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g6n6_VVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g10n22_VVV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {bar[Fd], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fd>::type, Fd>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fd>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fd>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fd, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fu], Fu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fu>::type, Fu>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fu>::type, Fu, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fe], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fe>::type, Fe>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fe>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fe>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fe, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hm -> {hh, VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Hm, hh, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hm>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<hh, Hm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Hm -> {Ah, VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Hm, Ah, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hm>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, Hm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Hm -> {VP, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hm, VP, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hm>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hm, typename conj<VWm>::type, VP>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hm -> {VZ, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hm, VZ, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hm>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hm, typename conj<VWm>::type, VZ>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hm -> {bar[Fu], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hm, typename bar<Fu>::type, Fd>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hm>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fu, Hm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hm -> {bar[Fv], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hm, typename bar<Fv>::type, Fe>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hm>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fv, Hm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {hh, hh}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, hh, hh>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<hh>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Hm, conj[Hm]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Hm, typename conj<Hm>::type>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::Hm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Hm>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Hm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Hm, typename conj<Hm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {hh, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VP>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Hm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g2n12_VV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.
                     value3(), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g10n30_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {hh, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZ>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {conj[Hm], VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, typename conj<Hm>::type, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::Hm>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<typename conj<Hm>::type>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, Hm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {Hm, conj[VWm]}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, Hm, typename conj<VWm>::type>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::Hm >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<Hm>(idx_2);
   result.m_vector = context.physical_mass<typename conj<VWm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, typename conj<Hm>::type, VWm>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {VG, VG}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VG, VG>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VG >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VG >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VG>(idx_2);
   result.m_vector_2 = context.physical_mass<VG>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VP}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VP>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VZ, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VZ, VZ>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Hm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Hm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], VWm
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hm, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VWm
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], hh
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, typename conj<Hm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {conj[VWm], VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, typename conj<VWm>::type, VWm>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<typename conj<VWm>::type>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, Hm
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Hm
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fd, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fu, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fv, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gP]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gP>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gP>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gZ]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gZ>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gZ, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gZ>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, Hm
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Hm
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, Hm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, Ah
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, hh
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, VP
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], Hm, VZ
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, VP
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, VP
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hm, VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, Hm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fd
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fd, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fu, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gP
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gP, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gP>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gZ, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gZ>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gZ>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hm, conj[Hm]
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hm, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, VP
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VP>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hm, VZ
   {
      using vertexId1 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VP
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hm], VZ
   {
      using vertexId1 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VP
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VP
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VP
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VP
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VP
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZ
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], hh
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], VP
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], VZ
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId2 = Vertex<Hm, typename conj<Hm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<Hm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, VP
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], VP
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId2 = Vertex<Hm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {bar[Fv], Fv}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fv>::type, Fv>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fv >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fv>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[Hm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[VWm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g3n3_FFV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[Hm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<Hm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hm, conj[VWm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Ah, typename conj<Hm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g4n4_SVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Ah, Hm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g5n5_VSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[Hm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<Hm>::type>;
      using vertexId3 = Vertex<Hm, typename conj<Hm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hm], VWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Hm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hm>::type, VWm>;
      using vertexId3 = Vertex<Hm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {bar[Fd], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fd>::type, Fd>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fd>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fd>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fd, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fu], Fu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fu>::type, Fu>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fu>::type, Fu, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fe], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fe>::type, Fe>(
   const context_base& context,
   typename THDMII_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename THDMII_cxx_diagrams::field_indices<typename fields::bar<fields::Fe>::type >::type const& idx_2,
   typename THDMII_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fe>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fe, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}


// -------- specializations for decays needing higher order SM corrections --------

using H = fields::hh;
using AH = fields::Ah;
using W = fields::VWm;
using Z = fields::VZ;
using G = fields::VG;
using A = fields::VP;
using lep = fields::Fe;
using uq = fields::Fu;
using dq = fields::Fd;

// List of potential Z boson decay products excluding pure SM decays
typedef boost::mpl::list<
   boost::mpl::list<fields::Ah, fields::hh>,
   boost::mpl::list<fields::hh, fields::Ah>,
   boost::mpl::list<fields::Hm, typename fields::conj<fields::Hm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hm>::type, fields::Hm>,
   boost::mpl::list<fields::hh, fields::VZ>,
   boost::mpl::list<fields::Hm, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hm>::type, fields::VWm>
> BSMForZdecay;

// List of potential W boson decay products excluding pure SM decays
typedef boost::mpl::list<
   boost::mpl::list<fields::Ah, typename fields::conj<fields::Hm>::type>,
   boost::mpl::list<fields::hh, typename fields::conj<fields::Hm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hm>::type, fields::Ah>,
   boost::mpl::list<typename fields::conj<fields::Hm>::type, fields::hh>,
   boost::mpl::list<fields::hh, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hm>::type, fields::VP>,
   boost::mpl::list<typename fields::conj<fields::Hm>::type, fields::VZ>
> BSMForWdecay;

template <typename DecayProds, typename V>
bool check_3body_Vff_decay(const context_base& context, double  mHOS, const typename field_indices<V>::type& idx)  {
   bool found_problem = false;
   const double mVOS {context.physical_mass<V>(idx)};
   boost::mpl::for_each<DecayProds>(
      [mHOS, mVOS, &idx, &context, &found_problem](auto arg) {
         using T = decltype(arg);
         using Field1 = typename boost::mpl::at<T, boost::mpl::int_<0>>::type;
         using Field2 = typename boost::mpl::at<T, boost::mpl::int_<1>>::type;
         using vertexId1 = Vertex<V, Field1, Field2>;
         for (const auto& indexId1: index_range<vertexId1>()) {
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            if (externalFieldIndicesIn1 != idx) {
               continue;
            }
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            const double mInternal2 {context.physical_mass<Field1>(externalFieldIndicesIn2)};
            const double mInternal3 {context.physical_mass<Field2>(externalFieldIndicesIn3)};

            if (mHOS-mVOS > mInternal2 + mInternal3
                && !Vertex<V, Field1, Field2>::evaluate(indexId1, context).isZero()) {
               found_problem = true;
            }
         }
      }
   );
   return found_problem;
}

#include "decays/H_SM_decays/decay_H_to_ZZ.inc"
#include "decays/H_SM_decays/decay_H_to_WW.inc"
#include "decays/H_SM_decays/decay_H_to_GG.inc"
#include "decays/H_SM_decays/decay_H_to_AA.inc"
#include "decays/H_SM_decays/decay_H_to_AZ.inc"
#include "decays/H_SM_decays/decay_H_to_uquq.inc"
#include "decays/H_SM_decays/decay_H_to_dqdq.inc"
#include "decays/H_SM_decays/decay_H_to_leplep.inc"
#include "decays/H_SM_decays/decay_AH_to_dqdq.inc"
#include "decays/H_SM_decays/decay_AH_to_uquq.inc"
#include "decays/H_SM_decays/decay_AH_to_GG.inc"
#include "decays/H_SM_decays/decay_AH_to_AA.inc"
#include "decays/H_SM_decays/decay_AH_to_AZ.inc"
#include "decays/H_SM_decays/decay_AH_to_leplep.inc"

void CLASSNAME::calculate_hh_decays()
{

   for (int gI1 = 0; gI1 < 2; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(Mhh);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         THDMII_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  THDMII_mass_eigenstates_decoupling_scheme>(model.get_input())
                  ;
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(Mhh);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<THDMII_mass_eigenstates>(model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_hh_decays(gI1);

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (gI1 == gO2) {
               continue;
            }
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<hh>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_hhhh(dec_model.get(), gI1, gO1
               , gO2), {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh,
               gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::hh,
               gO2)}, create_process_string<hh, hh, hh>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_hhAh(dec_model.get(), gI1, gO1
               , gO2), {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh,
               gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::Ah,
               gO2)}, create_process_string<hh, hh, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Ah>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_AhAh(dec_model.get(), gI1, gO1
               , gO2), {THDMII_info::get_pdg_code_for_particle(THDMII_info::Ah,
               gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::Ah,
               gO2)}, create_process_string<hh, Ah, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Hm>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Hm>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_HmconjHm(dec_model.get(), gI1,
               gO1, gO2), {THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Hm, gO1), -THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Hm, gO2)}, create_process_string<hh, Hm, typename conj<Hm>::type
               >({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVP(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP)},
            create_process_string<hh, hh, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVP(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::Ah, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP)},
            create_process_string<hh, Ah, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVZ(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<hh, hh, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVZ(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::Ah, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<hh, Ah, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<typename conj<Hm>::type>(std::array<int, 1> {gO1}) +
            context.physical_mass<VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_conjHmVWm(dec_model.get(), gI1,
            gO1), {-THDMII_info::get_pdg_code_for_particle(THDMII_info::Hm, gO1
            ), THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<hh, typename conj<Hm>::type, VWm>({gI1},{gO1}
            ,{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Hm>(std::array<int, 1> {gO1}) + context.physical_mass
            <typename conj<VWm>::type>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_HmconjVWm(dec_model.get(), gI1,
            gO1), {THDMII_info::get_pdg_code_for_particle(THDMII_info::Hm, gO1)
            , -THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<hh, Hm, typename conj<VWm>::type>({gI1},{gO1}
            ,{}));

      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VG>(std::array<int, 0> {}) + context.physical_mass<VG>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VGVG(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VG),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VG)},
            create_process_string<hh, VG, VG>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VP>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVP(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP)},
            create_process_string<hh, VP, VP>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVZ(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<hh, VP, VZ>({gI1},{},{}));
      }
         decays.set_decay(partial_width_hh_to_VZVZ(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<hh, VZ, VZ>({gI1},{},{}));
         decays.set_decay(partial_width_hh_to_conjVWmVWm(dec_model.get(), gI1),
            {-THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<hh, typename conj<VWm>::type, VWm>({gI1},{},{
            }));

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fv>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFvFv(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fv, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fv, gO2)}, create_process_string<hh, typename bar<Fv>::type, Fv>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fd>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFdFd(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fd, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fd, gO2)}, create_process_string<hh, typename bar<Fd>::type, Fd>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fu>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFuFu(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fu, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fu, gO2)}, create_process_string<hh, typename bar<Fu>::type, Fu>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fe>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFeFe(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fe, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fe, gO2)}, create_process_string<hh, typename bar<Fe>::type, Fe>
               ({gI1},{gO1},{gO2}));

         }
      }

   }


}

void CLASSNAME::calculate_Hm_decays()
{

   for (int gI1 = 1; gI1 < 2; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(MHm);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         THDMII_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  THDMII_mass_eigenstates_decoupling_scheme>(model.get_input())
                  ;
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(MHm);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<THDMII_mass_eigenstates>(model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_Hm_decays(gI1);

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         if (context.physical_mass<Hm>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Hm_to_hhVWm(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Hm, hh, VWm>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Hm>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Hm_to_AhVWm(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::Ah, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Hm, Ah, VWm>({gI1},{gO1},{}));

      }

      if (context.physical_mass<Hm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VWm>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hm_to_VPVWm(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Hm, VP, VWm>({gI1},{},{}));
      }

      if (context.physical_mass<Hm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VWm>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hm_to_VZVWm(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Hm, VZ, VWm>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hm>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hm_to_barFuFd(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fu, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fd, gO2)}, create_process_string<Hm, typename bar<Fu>::type, Fd>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hm>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hm_to_barFvFe(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fv, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fe, gO2)}, create_process_string<Hm, typename bar<Fv>::type, Fe>
               ({gI1},{gO1},{gO2}));

         }
      }

   }


}

void CLASSNAME::calculate_Ah_decays()
{

   for (int gI1 = 1; gI1 < 2; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(MAh);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         THDMII_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  THDMII_mass_eigenstates_decoupling_scheme>(model.get_input())
                  ;
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(MAh);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<THDMII_mass_eigenstates>(model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_Ah_decays(gI1);

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<hh>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_hhhh(dec_model.get(), gI1, gO1
               , gO2), {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh,
               gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::hh,
               gO2)}, create_process_string<Ah, hh, hh>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Hm>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Hm>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_HmconjHm(dec_model.get(), gI1,
               gO1, gO2), {THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Hm, gO1), -THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Hm, gO2)}, create_process_string<Ah, Hm, typename conj<Hm>::type
               >({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVP(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP)},
            create_process_string<Ah, hh, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVZ(dec_model.get(), gI1, gO1),
            {THDMII_info::get_pdg_code_for_particle(THDMII_info::hh, gO1),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<Ah, hh, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<typename conj<Hm>::type>(std::array<int, 1> {gO1}) +
            context.physical_mass<VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_conjHmVWm(dec_model.get(), gI1,
            gO1), {-THDMII_info::get_pdg_code_for_particle(THDMII_info::Hm, gO1
            ), THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Ah, typename conj<Hm>::type, VWm>({gI1},{gO1}
            ,{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<Hm>(std::array<int, 1> {gO1}) + context.physical_mass
            <typename conj<VWm>::type>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_HmconjVWm(dec_model.get(), gI1,
            gO1), {THDMII_info::get_pdg_code_for_particle(THDMII_info::Hm, gO1)
            , -THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Ah, Hm, typename conj<VWm>::type>({gI1},{gO1}
            ,{}));

      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VG>(std::array<int, 0> {}) + context.physical_mass<VG>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VGVG(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VG),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VG)},
            create_process_string<Ah, VG, VG>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VP>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVP(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP)},
            create_process_string<Ah, VP, VP>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVZ(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VP),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<Ah, VP, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VZVZ(dec_model.get(), gI1), {
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VZ)},
            create_process_string<Ah, VZ, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<typename conj<VWm>::type>(std::array<int, 0> {}) +
         context.physical_mass<VWm>(std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_conjVWmVWm(dec_model.get(), gI1),
            {-THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm),
            THDMII_info::get_pdg_code_for_particle(THDMII_info::VWm)},
            create_process_string<Ah, typename conj<VWm>::type, VWm>({gI1},{},{
            }));
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fv>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFvFv(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fv, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fv, gO2)}, create_process_string<Ah, typename bar<Fv>::type, Fv>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fd>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFdFd(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fd, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fd, gO2)}, create_process_string<Ah, typename bar<Fd>::type, Fd>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fu>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFuFu(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fu, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fu, gO2)}, create_process_string<Ah, typename bar<Fu>::type, Fu>
               ({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fe>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFeFe(dec_model.get(), gI1,
               gO1, gO2), {-THDMII_info::get_pdg_code_for_particle(THDMII_info
               ::Fe, gO1), THDMII_info::get_pdg_code_for_particle(THDMII_info::
               Fe, gO2)}, create_process_string<Ah, typename bar<Fe>::type, Fe>
               ({gI1},{gO1},{gO2}));

         }
      }

   }


}

double CLASSNAME::partial_width_hh_to_hhhh(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<hh>::type out_2_indices {{gO2}};

   return get_partial_width<hh, hh, hh>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhAh(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<hh, hh, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhAh(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Ah, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_HmconjHm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Hm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Hm>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Hm, typename conj<Hm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVP(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, hh, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVP(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, Ah, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVZ(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, hh, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVZ(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, Ah, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_conjHmVWm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename conj<Hm>::type>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<hh, typename conj<Hm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_HmconjVWm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Hm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<VWm>::type>::type out_2_indices {};

   return get_partial_width<hh, Hm, typename conj<VWm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VGVG(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VG>::type out_1_indices {};
   const typename field_indices<VG>::type out_2_indices {};

   return get_partial_width<hh, VG, VG>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVP(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, VP, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVZ(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, VP, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VZVZ(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, VZ, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_conjVWmVWm(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename conj<VWm>::type>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<hh, typename conj<VWm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFvFv(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fv>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fv>::type, Fv>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFdFd(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fd>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fd>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFuFu(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fu>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fu>::type, Fu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFeFe(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fe>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fe>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hm_to_hhVWm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Hm>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hm, hh, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hm_to_AhVWm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Hm>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hm, Ah, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hm_to_VPVWm(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hm>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hm, VP, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hm_to_VZVWm(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hm>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hm, VZ, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hm_to_barFuFd(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hm>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<Hm, typename bar<Fu>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hm_to_barFvFe(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hm>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<Hm, typename bar<Fv>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhhh(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<hh>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, hh, hh>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_HmconjHm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Hm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Hm>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Hm, typename conj<Hm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVP(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, hh, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVZ(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, hh, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_conjHmVWm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename conj<Hm>::type>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Ah, typename conj<Hm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_HmconjVWm(THDMII_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Hm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<VWm>::type>::type out_2_indices {};

   return get_partial_width<Ah, Hm, typename conj<VWm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VGVG(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VG>::type out_1_indices {};
   const typename field_indices<VG>::type out_2_indices {};

   return get_partial_width<Ah, VG, VG>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVP(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, VP, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVZ(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, VP, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VZVZ(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, VZ, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_conjVWmVWm(THDMII_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename conj<VWm>::type>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Ah, typename conj<VWm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFvFv(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fv>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fv>::type, Fv>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFdFd(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fd>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fd>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFuFu(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fu>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fu>::type, Fu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFeFe(THDMII_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fe>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fe>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}


} // namespace flexiblesusy
