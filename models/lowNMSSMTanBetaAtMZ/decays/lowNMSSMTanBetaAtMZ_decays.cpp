// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================


/**
 * @file lowNMSSMTanBetaAtMZ_decays.cpp
 * @brief implementation of particle decays in the lowNMSSMTanBetaAtMZ
 *
 * Contains the definition of lowNMSSMTanBetaAtMZ decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated with FlexibleSUSY 2.6.2 and SARAH 4.14.5 .
 */

#include <cmath>

#include <boost/range/algorithm.hpp>
#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
#define BOOST_MPL_LIMIT_LIST_SIZE 50
#include <boost/mpl/for_each.hpp>
#include <boost/mpl/int.hpp>
#include <boost/mpl/at.hpp>
#include <boost/mpl/list.hpp>

#include "lowNMSSMTanBetaAtMZ_decays.hpp"
#include "lowNMSSMTanBetaAtMZ_info.hpp"
#include "decays/one_loop_decay_diagrams.hpp"
#include "concatenate.hpp"
#include "decays/decay_functions.hpp"
#include "dilog.hpp"
#include "trilog.hpp"
#include "Li4.hpp"
#include "config.h"
#include "thread_pool.hpp"
#include "wrappers.hpp"
#include "standard_model.hpp"
#include <gsl/gsl_monte_miser.h>

namespace flexiblesusy {

#define CLASSNAME lowNMSSMTanBetaAtMZ_decays
#define PHYSICAL(parameter) model.get_physical().parameter

using namespace lowNMSSMTanBetaAtMZ_cxx_diagrams;
using namespace lowNMSSMTanBetaAtMZ_cxx_diagrams::fields;
namespace info = lowNMSSMTanBetaAtMZ_info;
using namespace std::complex_literals;

const lowNMSSMTanBetaAtMZ_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

const FlexibleDecay_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
try {
#ifdef ENABLE_THREADS
   Thread_pool tp(std::min(std::thread::hardware_concurrency(), 3u));

   tp.run_task([this] () { calculate_hh_decays(); });
   tp.run_task([this] () { calculate_Hpm_decays(); });
   tp.run_task([this] () { calculate_Ah_decays(); });

#else
   calculate_hh_decays();
   calculate_Hpm_decays();
   calculate_Ah_decays();

#endif
}
catch (std::exception& e) {
   problems.add_error(e.what());
}
}

double get_alphas(context_base const&  context)
{
   return Sqr(context.model.get_g3())/(4.*Pi);
}

double get_alpha(context_base const&  context)
{
   return Sqr(unit_charge(context))/(4.*Pi);
}

/* 1-loop BSM amplitudes
 *
 * Notes:
 *    - Since FS removes a factor of i from every vertex we reintroduce it
 *      calls to one loop amplitudes
 */

// hh -> {Sd, conj[Sd]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Sd, typename conj<Sd>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Sd >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Sd>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sd>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sd>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Sd, typename conj<Sd>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Sv, conj[Sv]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Sv, typename conj<Sv>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Sv >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Sv>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sv>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sv>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Sv, typename conj<Sv>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Su, conj[Su]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Su, typename conj<Su>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Su >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Su>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Su>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Su>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Su, typename conj<Su>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Se, conj[Se]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Se, typename conj<Se>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Se >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Se>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Se>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Se>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Se, typename conj<Se>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, hh}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, hh, hh>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<hh>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, hh, Ah>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_1, idx_2);
   const auto vertex =  Vertex<Ah, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Ah, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Ah, Ah>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Ah>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Ah, Ah, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Hpm, conj[Hpm]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Hpm, typename conj<Hpm>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Hpm>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Hpm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Hpm, typename conj<Hpm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VP>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VP>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, hh, VP>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {hh, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, VZ, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Sv
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWm], gWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g10n40_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], Ah
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, Ah
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], Ah
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], Ah
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], Ah
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, Ah
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, Ah
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], Ah
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, Ah
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], Ah
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], Ah
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], Ah
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZ
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], Ah
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g10n50_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZ>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {conj[Hpm], VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, typename conj<Hpm>::type, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<typename conj<Hpm>::type>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {Hpm, conj[VWm]}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Hpm, typename conj<VWm>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Hpm>(idx_2);
   result.m_vector = context.physical_mass<typename conj<VWm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, typename conj<Hpm>::type, VWm>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {VG, VG}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VG, VG>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VG >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VG >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VG>(idx_2);
   result.m_vector_2 = context.physical_mass<VG>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VP}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VP>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value3(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value2(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Hpm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Sd
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Se
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Su
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g2n14_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value3
                     (), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value3(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g10n40_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {VZ, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VZ, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, VZ, VZ>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {conj[VWm], VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, typename conj<VWm>::type, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<typename conj<VWm>::type>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, typename conj<VWm>::type, VWm>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {Glu, Glu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, Glu, Glu>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Glu >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Glu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<Glu>(idx_2);
   result.m_fermion_2 = context.physical_mass<Glu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Sd
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Glu, Sd>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Su
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Glu, Su>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, conj[Sd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Glu, Fd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, conj[Su]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Glu, Fu, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, bar[Fd]
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, bar[Fu]
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {bar[Fv], Fv}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fv>::type, Fv>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fv >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fv>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Chi, Chi, Sv
   {
      using vertexId1 = Vertex<Chi, Fv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Chi, Sv>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[Hpm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hpm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hpm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[VWm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g3n3_FFV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, bar[Cha]
   {
      using vertexId1 = Vertex<Cha, Fv, typename conj<Se>::type>;
      using vertexId2 = Vertex<typename bar<Cha>::type, typename bar<Fv>::type, Se>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Cha>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, Chi
   {
      using vertexId1 = Vertex<Chi, Fv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Chi, Sv>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, VZ, Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g6n6_VVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Se
   {
      using vertexId1 = Vertex<Cha, Fv, typename conj<Se>::type>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<typename bar<Cha>::type, typename bar<Fv>::type, Se>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hpm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hpm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g4n4_SVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g5n5_VSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g6n6_VVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.right(
                        ), 1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g10n22_VVV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {Chi, Chi}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, Chi, Chi>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Chi >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Chi >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<Chi>(idx_2);
   result.m_fermion_2 = context.physical_mass<Chi>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Chi, Chi, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Cha], Cha}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Cha>::type, Cha>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Cha>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Cha >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Cha>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Cha>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Cha>::type, Cha, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fe], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fe>::type, Fe>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fe>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fe>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fe, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fd], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fd>::type, Fd>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fd>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fd>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fd, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fu], Fu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fu>::type, Fu>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fu>::type, Fu, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hpm -> {Sd, conj[Su]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Hpm, Sd, typename conj<Su>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Sd >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Su>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sd>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Su>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, Su, typename conj<Sd>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Hpm -> {Se, conj[Sv]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Hpm, Se, typename conj<Sv>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Se >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Sv>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar_1 = context.physical_mass<Se>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sv>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, Sv, typename conj<Se>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Hpm -> {hh, VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Hpm, hh, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<hh, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Hpm -> {Ah, VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Hpm, Ah, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Hpm -> {VP, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hpm, VP, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, typename conj<VWm>::type, VP>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hpm -> {VZ, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hpm, VZ, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, typename conj<VWm>::type, VZ>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hpm -> {Chi, Cha}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hpm, Chi, Cha>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Chi >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Cha >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_fermion_1 = context.physical_mass<Chi>(idx_2);
   result.m_fermion_2 = context.physical_mass<Cha>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Cha>::type, Chi, Hpm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hpm -> {bar[Fv], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hpm, typename bar<Fv>::type, Fe>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fv, Hpm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hpm -> {bar[Fu], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hpm, typename bar<Fu>::type, Fd>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fu, Hpm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {Sd, conj[Sd]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Sd, typename conj<Sd>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Sd >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Sd>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sd>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sd>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Sd, typename conj<Sd>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Sv, conj[Sv]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Sv, typename conj<Sv>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Sv >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Sv>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sv>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sv>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Cha, Sv>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Fe, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g1n1_FFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, bar[Fv]
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Chi, Sv>;
      using vertexId3 = Vertex<Chi, Fv, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g1n1_FFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g2n2_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g5n5_SVS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Se, typename conj<Hpm>::type, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Hpm, Sv, typename conj<Se>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g2n2_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Se, typename conj<Hpm>::type, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Se>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g5n5_SVS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Se]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Se, typename conj<Sv>::type, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, Sv, typename conj<Se>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g6n6_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g6n6_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Cha
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Cha, Sv>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Fe, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g1n1_FFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Hpm
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Hpm>::type, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Hpm, Sv, typename conj<Se>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g2n2_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], VWm
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Sv>::type, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Se>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t1g4n4_SSV(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t4g1n15_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t4g1n15_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, Sv, typename conj<Hpm>::type, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t4g1n15_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, Sv, typename conj<Sd>::type, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t4g1n15_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, Sv, typename conj<Se>::type, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t4g1n15_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, Sv, typename conj<Su>::type, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t4g1n15_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t5g1n17_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t5g1n17_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t5g1n17_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t5g1n17_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t5g1n17_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t5g1n17_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[Se]
   {
      using vertexId1 = Vertex<Se, typename conj<Hpm>::type, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, Hpm, Sv, typename conj<Se>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<0>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t6g1n19_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Se, conj[Hpm]
   {
      using vertexId1 = Vertex<Hpm, Sv, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Hpm>::type, typename conj<Sv>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSS_t7g1n21_SS(
                  result.m_decay, result.m_scalar_1, result.m_scalar_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g7n49_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g1n43_SFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g6n48_VFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g1n43_SFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g6n48_VFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g1n43_SFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g6n48_VFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g1n43_SFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g6n48_VFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g1n43_SFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g6n48_VFF(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g3n45_SUU(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g8n50_VUU(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), -1.0i*vertexId3Val.
                        value(1), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g3n45_SUU(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g8n50_VUU(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), -1.0i*vertexId3Val.
                        value(1), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZ
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g9n51_VSV(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g7n49_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g4n46_SSV(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g9n51_VSV(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g7n49_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g7n49_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g2n44_SSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g7n49_VSS(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g4n46_SSV(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSS_t10g9n51_VSV(
                     result.m_decay, result.m_scalar_1, result.m_scalar_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {Su, conj[Su]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Su, typename conj<Su>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Su >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Su>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Su>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Su>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Su, typename conj<Su>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Se, conj[Se]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Se, typename conj<Se>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Se >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Se>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Se>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Se>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Se, typename conj<Se>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {hh, hh}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, hh, hh>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<hh>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {hh, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, hh, Ah>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Ah, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Ah, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Ah, Ah>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Ah>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, Ah, Ah>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Hpm, conj[Hpm]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Hpm, typename conj<Hpm>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Hpm>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Hpm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Hpm, typename conj<Hpm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {hh, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VP>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, VP>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {Ah, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, Ah, VP>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {hh, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZ>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {Ah, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, Ah, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, Ah, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: hh, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: hh, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: hh, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: hh, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, bar[gWm], gWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: hh, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {conj[Hpm], VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, typename conj<Hpm>::type, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<typename conj<Hpm>::type>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {Hpm, conj[VWm]}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, Hpm, typename conj<VWm>::type>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<Hpm>(idx_2);
   result.m_vector = context.physical_mass<typename conj<VWm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, typename conj<Hpm>::type, VWm>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {VG, VG}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VG, VG>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VG >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VG >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VG>(idx_2);
   result.m_vector_2 = context.physical_mass<VG>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VP}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VP>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VZ, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VZ, VZ>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {conj[VWm], VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, typename conj<VWm>::type, VWm>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<typename conj<VWm>::type>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, Chi
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<Chi, Cha, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Chi, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Cha
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Cha, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Chi, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fd, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fu, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fv, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gP]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gP>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gP>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gZ]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gZ>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gZ, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gZ>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, Ah
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Su, typename conj<Sd>::type, VWm>;
      using vertexId3 = Vertex<Sd, typename conj<Su>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Se>::type, VWm>;
      using vertexId3 = Vertex<Se, typename conj<Sv>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, VP
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fd
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fd, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fu, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gP
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gP, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gP>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gZ, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gZ>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gZ>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Sd
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Sd>::type, VWm>;
      using vertexId3 = Vertex<Sd, typename conj<Su>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Ah, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<1>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, VP
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VP>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, VZ
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VP
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VZ
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VP
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VP
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VP
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VP
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VP
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VP
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZ
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VP
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VP
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VP
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VP
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {Glu, Glu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, Glu, Glu>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Glu >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Glu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<Glu>(idx_2);
   result.m_fermion_2 = context.physical_mass<Glu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Sd
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Glu, Sd>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Su
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Glu, Su>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, conj[Sd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<Glu, Fd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, conj[Su]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<Glu, Fu, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, bar[Fd]
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, bar[Fu]
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {bar[Fv], Fv}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fv>::type, Fv>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fv >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fv>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Chi, Chi, Sv
   {
      using vertexId1 = Vertex<Chi, Fv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Chi, Sv>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[Hpm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hpm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hpm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, conj[VWm]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g3n3_FFV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, bar[Cha]
   {
      using vertexId1 = Vertex<Cha, Fv, typename conj<Se>::type>;
      using vertexId2 = Vertex<typename bar<Cha>::type, typename bar<Fv>::type, Se>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Cha>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Se
   {
      using vertexId1 = Vertex<Cha, Fv, typename conj<Se>::type>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<typename bar<Cha>::type, typename bar<Fv>::type, Se>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hpm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, Hpm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g4n4_SVF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fv, VWm>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g5n5_VSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.right(
                        ), 1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g6n18_VFF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.left(
                        ), -1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g8n20_VUU(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), -1.0i*vertexId3Val.value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g7n19_VSS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        ), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<0>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t5g9n21_VSV(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.value(
                        0, 1), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {Chi, Chi}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, Chi, Chi>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Chi >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Chi >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<Chi>(idx_2);
   result.m_fermion_2 = context.physical_mass<Chi>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Chi, Chi, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Cha], Cha}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Cha>::type, Cha>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Cha>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Cha >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Cha>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Cha>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Cha>::type, Cha, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fe], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fe>::type, Fe>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fe>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fe>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fe, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fd], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fd>::type, Fd>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fd>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fd>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fd, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fu], Fu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fu>::type, Fu>(
   const context_base& context,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename lowNMSSMTanBetaAtMZ_cxx_diagrams::field_indices<fields::Fu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fu>::type, Fu, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}


// -------- specializations for decays needing higher order SM corrections --------

using H = fields::hh;
using AH = fields::Ah;
using W = fields::VWm;
using Z = fields::VZ;
using G = fields::VG;
using A = fields::VP;
using lep = fields::Fe;
using uq = fields::Fu;
using dq = fields::Fd;

// List of potential Z boson decay products excluding pure SM decays
typedef boost::mpl::list<
   boost::mpl::list<fields::Ah, fields::hh>,
   boost::mpl::list<fields::Cha, typename fields::bar<fields::Cha>::type>,
   boost::mpl::list<fields::Chi, fields::Chi>,
   boost::mpl::list<fields::hh, fields::Ah>,
   boost::mpl::list<fields::Hpm, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<fields::Sd, typename fields::conj<fields::Sd>::type>,
   boost::mpl::list<fields::Se, typename fields::conj<fields::Se>::type>,
   boost::mpl::list<fields::Su, typename fields::conj<fields::Su>::type>,
   boost::mpl::list<fields::Sv, typename fields::conj<fields::Sv>::type>,
   boost::mpl::list<typename fields::bar<fields::Cha>::type, fields::Cha>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::Hpm>,
   boost::mpl::list<typename fields::conj<fields::Sd>::type, fields::Sd>,
   boost::mpl::list<typename fields::conj<fields::Se>::type, fields::Se>,
   boost::mpl::list<typename fields::conj<fields::Su>::type, fields::Su>,
   boost::mpl::list<typename fields::conj<fields::Sv>::type, fields::Sv>,
   boost::mpl::list<fields::hh, fields::VP>,
   boost::mpl::list<fields::hh, fields::VZ>,
   boost::mpl::list<fields::Hpm, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VWm>
> BSMForZdecay;

// List of potential W boson decay products excluding pure SM decays
typedef boost::mpl::list<
   boost::mpl::list<fields::Ah, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<fields::Chi, typename fields::bar<fields::Cha>::type>,
   boost::mpl::list<fields::hh, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<fields::Su, typename fields::conj<fields::Sd>::type>,
   boost::mpl::list<fields::Sv, typename fields::conj<fields::Se>::type>,
   boost::mpl::list<typename fields::bar<fields::Cha>::type, fields::Chi>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::Ah>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::hh>,
   boost::mpl::list<typename fields::conj<fields::Sd>::type, fields::Su>,
   boost::mpl::list<typename fields::conj<fields::Se>::type, fields::Sv>,
   boost::mpl::list<fields::hh, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VP>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VZ>
> BSMForWdecay;

template <typename DecayProds, typename V>
bool check_3body_Vff_decay(const context_base& context, double  mHOS, const typename field_indices<V>::type& idx)  {
   bool found_problem = false;
   const double mVOS {context.physical_mass<V>(idx)};
   boost::mpl::for_each<DecayProds>(
      [mHOS, mVOS, &idx, &context, &found_problem](auto arg) {
         using T = decltype(arg);
         using Field1 = typename boost::mpl::at<T, boost::mpl::int_<0>>::type;
         using Field2 = typename boost::mpl::at<T, boost::mpl::int_<1>>::type;
         using vertexId1 = Vertex<V, Field1, Field2>;
         for (const auto& indexId1: index_range<vertexId1>()) {
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            if (externalFieldIndicesIn1 != idx) {
               continue;
            }
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            const double mInternal2 {context.physical_mass<Field1>(externalFieldIndicesIn2)};
            const double mInternal3 {context.physical_mass<Field2>(externalFieldIndicesIn3)};

            if (mHOS-mVOS > mInternal2 + mInternal3
                && !Vertex<V, Field1, Field2>::evaluate(indexId1, context).isZero()) {
               found_problem = true;
            }
         }
      }
   );
   return found_problem;
}

#include "decays/H_SM_decays/decay_H_to_ZZ.inc"
#include "decays/H_SM_decays/decay_H_to_WW.inc"
#include "decays/H_SM_decays/decay_H_to_GG.inc"
#include "decays/H_SM_decays/decay_H_to_AA.inc"
#include "decays/H_SM_decays/decay_H_to_AZ.inc"
#include "decays/H_SM_decays/decay_H_to_uquq.inc"
#include "decays/H_SM_decays/decay_H_to_dqdq.inc"
#include "decays/H_SM_decays/decay_H_to_leplep.inc"
#include "decays/H_SM_decays/decay_AH_to_dqdq.inc"
#include "decays/H_SM_decays/decay_AH_to_uquq.inc"
#include "decays/H_SM_decays/decay_AH_to_GG.inc"
#include "decays/H_SM_decays/decay_AH_to_AA.inc"
#include "decays/H_SM_decays/decay_AH_to_AZ.inc"
#include "decays/H_SM_decays/decay_AH_to_leplep.inc"

void CLASSNAME::calculate_hh_decays()
{

   for (int gI1 = 0; gI1 < 3; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(Mhh);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         lowNMSSMTanBetaAtMZ_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  lowNMSSMTanBetaAtMZ_mass_eigenstates_decoupling_scheme>(model
                  .get_input());
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(Mhh);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<lowNMSSMTanBetaAtMZ_mass_eigenstates>(
                  model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_hh_decays(gI1);

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sd>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sd>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SdconjSd(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Sd, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Sd, gO2)},
               create_process_string<hh, Sd, typename conj<Sd>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sv>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sv>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SvconjSv(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Sv, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Sv, gO2)},
               create_process_string<hh, Sv, typename conj<Sv>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Su>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Su>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SuconjSu(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Su, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Su, gO2)},
               create_process_string<hh, Su, typename conj<Su>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Se>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Se>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SeconjSe(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Se, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Se, gO2)},
               create_process_string<hh, Se, typename conj<Se>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (gI1 == gO2) {
               continue;
            }
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<hh>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_hhhh(dec_model.get(), gI1, gO1
               , gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::hh, gO2)},
               create_process_string<hh, hh, hh>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 1; gO2 < 3; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_hhAh(dec_model.get(), gI1, gO1
               , gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Ah, gO2)},
               create_process_string<hh, hh, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         for (int gO2 = 1; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Ah>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_AhAh(dec_model.get(), gI1, gO1
               , gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Ah, gO2)},
               create_process_string<hh, Ah, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO2}
               )) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_HpmconjHpm(dec_model.get(),
               gI1, gO1, gO2), {lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Hpm, gO1), -
               lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Hpm, gO2)}, create_process_string<hh,
               Hpm, typename conj<Hpm>::type>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVP(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VP)},
            create_process_string<hh, hh, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVP(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VP)},
            create_process_string<hh, Ah, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVZ(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<hh, hh, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVZ(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<hh, Ah, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO1}) +
            context.physical_mass<VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_conjHpmVWm(dec_model.get(), gI1,
            gO1), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Hpm, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<hh, typename conj<Hpm>::type, VWm>({gI1},{gO1
            },{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
            physical_mass<typename conj<VWm>::type>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_HpmconjVWm(dec_model.get(), gI1,
            gO1), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Hpm, gO1), -lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<hh, Hpm, typename conj<VWm>::type>({gI1},{gO1
            },{}));

      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VG>(std::array<int, 0> {}) + context.physical_mass<VG>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VGVG(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VG), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VG)},
            create_process_string<hh, VG, VG>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VP>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVP(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VP), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VP)},
            create_process_string<hh, VP, VP>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVZ(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VP), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<hh, VP, VZ>({gI1},{},{}));
      }
         decays.set_decay(partial_width_hh_to_VZVZ(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VZ), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<hh, VZ, VZ>({gI1},{},{}));
         decays.set_decay(partial_width_hh_to_conjVWmVWm(dec_model.get(), gI1),
            {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VWm), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<hh, typename conj<VWm>::type, VWm>({gI1},{},{
            }));

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<Glu>(std::array<int, 0> {}) + context.physical_mass<Glu>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_GluGlu(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Glu), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Glu)},
            create_process_string<hh, Glu, Glu>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fv>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFvFv(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fv, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fv, gO2)},
               create_process_string<hh, typename bar<Fv>::type, Fv>({gI1},{gO1
               },{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 5; ++gO1) {
         for (int gO2 = 0; gO2 < 5; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Chi>(std::array<int, 1> {gO1}) + context.
               physical_mass<Chi>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_ChiChi(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Chi, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Chi, gO2)},
               create_process_string<hh, Chi, Chi>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Cha>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Cha>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barChaCha(dec_model.get(), gI1
               , gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Cha, gO1),
               lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Cha, gO2)}, create_process_string<hh,
               typename bar<Cha>::type, Cha>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fe>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFeFe(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fe, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fe, gO2)},
               create_process_string<hh, typename bar<Fe>::type, Fe>({gI1},{gO1
               },{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fd>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFdFd(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fd, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fd, gO2)},
               create_process_string<hh, typename bar<Fd>::type, Fd>({gI1},{gO1
               },{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fu>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFuFu(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fu, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fu, gO2)},
               create_process_string<hh, typename bar<Fu>::type, Fu>({gI1},{gO1
               },{gO2}));

         }
      }

   }


}

void CLASSNAME::calculate_Hpm_decays()
{

   for (int gI1 = 1; gI1 < 2; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(MHpm);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         lowNMSSMTanBetaAtMZ_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  lowNMSSMTanBetaAtMZ_mass_eigenstates_decoupling_scheme>(model
                  .get_input());
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(MHpm);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<lowNMSSMTanBetaAtMZ_mass_eigenstates>(
                  model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_Hpm_decays(gI1);

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sd>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Su>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_SdconjSu(dec_model.get(), gI1
               , gO1, gO2), {lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Sd, gO1), -
               lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Su, gO2)}, create_process_string<Hpm,
               Sd, typename conj<Su>::type>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<Se>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sv>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_SeconjSv(dec_model.get(), gI1
               , gO1, gO2), {lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Se, gO1), -
               lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Sv, gO2)}, create_process_string<Hpm,
               Se, typename conj<Sv>::type>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Hpm_to_hhVWm(dec_model.get(), gI1, gO1)
            , {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Hpm, hh, VWm>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Hpm_to_AhVWm(dec_model.get(), gI1, gO1)
            , {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Hpm, Ah, VWm>({gI1},{gO1},{}));

      }

      if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VWm>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hpm_to_VPVWm(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VP), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Hpm, VP, VWm>({gI1},{},{}));
      }

      if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VWm>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hpm_to_VZVWm(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VZ), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Hpm, VZ, VWm>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 5; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<Chi>(std::array<int, 1> {gO1}) + context.
               physical_mass<Cha>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_ChiCha(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Chi, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Cha, gO2)},
               create_process_string<Hpm, Chi, Cha>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_barFvFe(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fv, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fe, gO2)},
               create_process_string<Hpm, typename bar<Fv>::type, Fe>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_barFuFd(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fu, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fd, gO2)},
               create_process_string<Hpm, typename bar<Fu>::type, Fd>({gI1},{
               gO1},{gO2}));

         }
      }

   }


}

void CLASSNAME::calculate_Ah_decays()
{

   for (int gI1 = 1; gI1 < 3; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(MAh);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         lowNMSSMTanBetaAtMZ_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  lowNMSSMTanBetaAtMZ_mass_eigenstates_decoupling_scheme>(model
                  .get_input());
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(MAh);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<lowNMSSMTanBetaAtMZ_mass_eigenstates>(
                  model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_Ah_decays(gI1);

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sd>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sd>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SdconjSd(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Sd, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Sd, gO2)},
               create_process_string<Ah, Sd, typename conj<Sd>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sv>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sv>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SvconjSv(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Sv, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Sv, gO2)},
               create_process_string<Ah, Sv, typename conj<Sv>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Su>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Su>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SuconjSu(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Su, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Su, gO2)},
               create_process_string<Ah, Su, typename conj<Su>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Se>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Se>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SeconjSe(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Se, gO1), -lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Se, gO2)},
               create_process_string<Ah, Se, typename conj<Se>::type>({gI1},{
               gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<hh>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_hhhh(dec_model.get(), gI1, gO1
               , gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::hh, gO2)},
               create_process_string<Ah, hh, hh>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 1; gO2 < 3; ++gO2) {
            if (gI1 == gO2) {
               continue;
            }
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_hhAh(dec_model.get(), gI1, gO1
               , gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Ah, gO2)},
               create_process_string<Ah, hh, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         for (int gO2 = 1; gO2 < 3; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (gI1 == gO2) {
               continue;
            }
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Ah>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_AhAh(dec_model.get(), gI1, gO1
               , gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Ah, gO2)},
               create_process_string<Ah, Ah, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO2}
               )) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_HpmconjHpm(dec_model.get(),
               gI1, gO1, gO2), {lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Hpm, gO1), -
               lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Hpm, gO2)}, create_process_string<Ah,
               Hpm, typename conj<Hpm>::type>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVP(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VP)},
            create_process_string<Ah, hh, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_AhVP(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VP)},
            create_process_string<Ah, Ah, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVZ(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::hh, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<Ah, hh, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_AhVZ(dec_model.get(), gI1, gO1),
            {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Ah, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<Ah, Ah, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO1}) +
            context.physical_mass<VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_conjHpmVWm(dec_model.get(), gI1,
            gO1), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Hpm, gO1), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Ah, typename conj<Hpm>::type, VWm>({gI1},{gO1
            },{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
            physical_mass<typename conj<VWm>::type>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_HpmconjVWm(dec_model.get(), gI1,
            gO1), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Hpm, gO1), -lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Ah, Hpm, typename conj<VWm>::type>({gI1},{gO1
            },{}));

      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VG>(std::array<int, 0> {}) + context.physical_mass<VG>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VGVG(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VG), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VG)},
            create_process_string<Ah, VG, VG>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VP>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVP(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VP), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VP)},
            create_process_string<Ah, VP, VP>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVZ(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VP), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<Ah, VP, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VZVZ(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VZ), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VZ)},
            create_process_string<Ah, VZ, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<typename conj<VWm>::type>(std::array<int, 0> {}) +
         context.physical_mass<VWm>(std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_conjVWmVWm(dec_model.get(), gI1),
            {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::VWm), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::VWm)},
            create_process_string<Ah, typename conj<VWm>::type, VWm>({gI1},{},{
            }));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<Glu>(std::array<int, 0> {}) + context.physical_mass<Glu>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_GluGlu(dec_model.get(), gI1), {
            lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
            lowNMSSMTanBetaAtMZ_info::Glu), lowNMSSMTanBetaAtMZ_info::
            get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Glu)},
            create_process_string<Ah, Glu, Glu>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fv>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFvFv(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fv, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fv, gO2)},
               create_process_string<Ah, typename bar<Fv>::type, Fv>({gI1},{gO1
               },{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 5; ++gO1) {
         for (int gO2 = 0; gO2 < 5; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Chi>(std::array<int, 1> {gO1}) + context.
               physical_mass<Chi>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_ChiChi(dec_model.get(), gI1,
               gO1, gO2), {lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Chi, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Chi, gO2)},
               create_process_string<Ah, Chi, Chi>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Cha>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Cha>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barChaCha(dec_model.get(), gI1
               , gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Cha, gO1),
               lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle(
               lowNMSSMTanBetaAtMZ_info::Cha, gO2)}, create_process_string<Ah,
               typename bar<Cha>::type, Cha>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fe>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFeFe(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fe, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fe, gO2)},
               create_process_string<Ah, typename bar<Fe>::type, Fe>({gI1},{gO1
               },{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fd>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFdFd(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fd, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fd, gO2)},
               create_process_string<Ah, typename bar<Fd>::type, Fd>({gI1},{gO1
               },{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fu>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFuFu(dec_model.get(), gI1,
               gO1, gO2), {-lowNMSSMTanBetaAtMZ_info::get_pdg_code_for_particle
               (lowNMSSMTanBetaAtMZ_info::Fu, gO1), lowNMSSMTanBetaAtMZ_info::
               get_pdg_code_for_particle(lowNMSSMTanBetaAtMZ_info::Fu, gO2)},
               create_process_string<Ah, typename bar<Fu>::type, Fu>({gI1},{gO1
               },{gO2}));

         }
      }

   }


}

double CLASSNAME::partial_width_hh_to_SdconjSd(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Sd>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sd>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Sd, typename conj<Sd>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_SvconjSv(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Sv>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sv>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Sv, typename conj<Sv>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_SuconjSu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Su>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Su>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Su, typename conj<Su>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_SeconjSe(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Se>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Se>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Se, typename conj<Se>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhhh(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<hh>::type out_2_indices {{gO2}};

   return get_partial_width<hh, hh, hh>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhAh(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<hh, hh, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhAh(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Ah, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_HpmconjHpm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Hpm, typename conj<Hpm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVP(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, hh, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVP(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, Ah, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, hh, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, Ah, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_conjHpmVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<hh, typename conj<Hpm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_HpmconjVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<VWm>::type>::type out_2_indices {};

   return get_partial_width<hh, Hpm, typename conj<VWm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VGVG(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VG>::type out_1_indices {};
   const typename field_indices<VG>::type out_2_indices {};

   return get_partial_width<hh, VG, VG>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVP(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, VP, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, VP, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VZVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, VZ, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_conjVWmVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename conj<VWm>::type>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<hh, typename conj<VWm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_GluGlu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Glu>::type out_1_indices {};
   const typename field_indices<Glu>::type out_2_indices {};

   return get_partial_width<hh, Glu, Glu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFvFv(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fv>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fv>::type, Fv>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_ChiChi(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Chi>::type out_1_indices {{gO1}};
   const typename field_indices<Chi>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Chi, Chi>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barChaCha(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Cha>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Cha>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Cha>::type, Cha>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFeFe(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fe>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fe>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFdFd(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fd>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fd>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFuFu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fu>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fu>::type, Fu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_SdconjSu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Sd>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Su>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, Sd, typename conj<Su>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_SeconjSv(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Se>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sv>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, Se, typename conj<Sv>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_hhVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, hh, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_AhVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, Ah, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_VPVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, VP, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_VZVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, VZ, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_ChiCha(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Chi>::type out_1_indices {{gO1}};
   const typename field_indices<Cha>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, Chi, Cha>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_barFvFe(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, typename bar<Fv>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_barFuFd(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, typename bar<Fu>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SdconjSd(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Sd>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sd>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Sd, typename conj<Sd>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SvconjSv(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Sv>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sv>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Sv, typename conj<Sv>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SuconjSu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Su>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Su>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Su, typename conj<Su>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SeconjSe(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Se>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Se>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Se, typename conj<Se>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhhh(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<hh>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, hh, hh>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhAh(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, hh, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_AhAh(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Ah, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_HpmconjHpm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Hpm, typename conj<Hpm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVP(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, hh, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_AhVP(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, Ah, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, hh, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_AhVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, Ah, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_conjHpmVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Ah, typename conj<Hpm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_HpmconjVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<VWm>::type>::type out_2_indices {};

   return get_partial_width<Ah, Hpm, typename conj<VWm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VGVG(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VG>::type out_1_indices {};
   const typename field_indices<VG>::type out_2_indices {};

   return get_partial_width<Ah, VG, VG>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVP(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, VP, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, VP, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VZVZ(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, VZ, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_conjVWmVWm(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename conj<VWm>::type>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Ah, typename conj<VWm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_GluGlu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Glu>::type out_1_indices {};
   const typename field_indices<Glu>::type out_2_indices {};

   return get_partial_width<Ah, Glu, Glu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFvFv(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fv>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fv>::type, Fv>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_ChiChi(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Chi>::type out_1_indices {{gO1}};
   const typename field_indices<Chi>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Chi, Chi>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barChaCha(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Cha>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Cha>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Cha>::type, Cha>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFeFe(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fe>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fe>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFdFd(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fd>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fd>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFuFu(lowNMSSMTanBetaAtMZ_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fu>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fu>::type, Fu>(context, in_indices, out_1_indices, out_2_indices);
}


} // namespace flexiblesusy
