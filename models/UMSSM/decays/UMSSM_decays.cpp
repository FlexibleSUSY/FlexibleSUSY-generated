// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================


/**
 * @file UMSSM_decays.cpp
 * @brief implementation of particle decays in the UMSSM
 *
 * Contains the definition of UMSSM decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated with FlexibleSUSY 2.6.1 and SARAH 4.14.5 .
 */

#include <cmath>

#include <boost/range/algorithm.hpp>
#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
#define BOOST_MPL_LIMIT_LIST_SIZE 50
#include <boost/mpl/for_each.hpp>
#include <boost/mpl/int.hpp>
#include <boost/mpl/at.hpp>
#include <boost/mpl/list.hpp>

#include "UMSSM_decays.hpp"
#include "UMSSM_info.hpp"
#include "decays/one_loop_decay_diagrams.hpp"
#include "concatenate.hpp"
#include "decays/decay_functions.hpp"
#include "dilog.hpp"
#include "trilog.hpp"
#include "Li4.hpp"
#include "config.h"
#include "thread_pool.hpp"
#include "wrappers.hpp"
#include "standard_model.hpp"
#include <gsl/gsl_monte_miser.h>

namespace flexiblesusy {

#define CLASSNAME UMSSM_decays
#define PHYSICAL(parameter) model.get_physical().parameter

using namespace UMSSM_cxx_diagrams;
using namespace UMSSM_cxx_diagrams::fields;
namespace info = UMSSM_info;
using namespace std::complex_literals;

const UMSSM_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

const FlexibleDecay_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
try {
#ifdef ENABLE_THREADS
   Thread_pool tp(std::min(std::thread::hardware_concurrency(), 3u));

   tp.run_task([this] () { calculate_hh_decays(); });
   tp.run_task([this] () { calculate_Hpm_decays(); });
   tp.run_task([this] () { calculate_Ah_decays(); });

#else
   calculate_hh_decays();
   calculate_Hpm_decays();
   calculate_Ah_decays();

#endif
}
catch (std::exception& e) {
   problems.add_error(e.what());
}
}

double get_alphas(context_base const&  context)
{
   return Sqr(context.model.get_g3())/(4.*Pi);
}

double get_alpha(context_base const&  context)
{
   return Sqr(unit_charge(context))/(4.*Pi);
}

/* 1-loop BSM amplitudes
 *
 * Notes:
 *    - Since FS removes a factor of i from every vertex we reintroduce it
 *      calls to one loop amplitudes
 */

// hh -> {Sd, conj[Sd]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Sd, typename conj<Sd>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Sd >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Sd>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sd>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sd>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Sd, typename conj<Sd>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Sv, conj[Sv]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Sv, typename conj<Sv>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Sv >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Sv>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sv>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sv>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Sv, typename conj<Sv>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Su, conj[Su]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Su, typename conj<Su>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Su >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Su>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Su>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Su>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Su, typename conj<Su>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Se, conj[Se]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Se, typename conj<Se>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Se >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Se>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Se>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Se>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Se, typename conj<Se>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, hh}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, hh, hh>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<hh>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, hh, Ah>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_1, idx_2);
   const auto vertex =  Vertex<Ah, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Ah, Ah}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Ah, Ah>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Ah>(idx_2);
   result.m_scalar_2 = context.physical_mass<Ah>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Ah, Ah, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {Hpm, conj[Hpm]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<hh, Hpm, typename conj<Hpm>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar_1 = context.physical_mass<Hpm>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Hpm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, Hpm, typename conj<Hpm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// hh -> {hh, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VP>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VP>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, Ah>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g2n12_VV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.
                     value3(), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g2n12_VV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.
                     value3(), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g10n30_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g10n30_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {hh, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, VZ, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, VZp, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fv, bar[Fv], Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Sv
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fv], Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Sv
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sv, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWm], gWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Ah, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g10n40_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, VZp>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g10n40_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], Ah
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZp
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, Ah
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZp
   {
      using vertexId1 = Vertex<Chi, Chi, VZp>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], Ah
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZp
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], Ah
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZp
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], Ah
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZp
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], Ah
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], VZp
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, Ah
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZp
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, Ah
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZp
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], Ah
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZp
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, Ah
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZp
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], Ah
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZp
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], Ah
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZp
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], Ah
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZp
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], Ah
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZ
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZp
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], Ah
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZp
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g10n50_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZp
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g10n50_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZ>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {hh, VZp}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, hh, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, VZ, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, VZp, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, VZp>;
      using vertexId3 = Vertex<Chi, Chi, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fv, bar[Fv], Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Sv
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fv], Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g9n9_VVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g10n10_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: Ah, Sv
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t3g1n13_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sv, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t5g1n16_SS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, Ah, hh>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g1n31_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWm], gWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g3n33_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Ah, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g2n32_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: Ah, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g4n34_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(1, 0), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Ah, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g10n40_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Ah, hh
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Ah, hh, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, VZp>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g6n36_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g8n38_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Sv, conj[Sv]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g7n37_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g9n39_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t9g10n40_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Ah, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], Ah
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZp
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, Ah
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZp
   {
      using vertexId1 = Vertex<Chi, Chi, VZp>;
      using vertexId2 = Vertex<Chi, Chi, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], Ah
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZp
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], Ah
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZp
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], Ah
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZp
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], Ah
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g1n41_SFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], VZp
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g6n46_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, Ah
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZp
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, Ah
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g3n43_SUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZp
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g8n48_VUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<hh, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], Ah
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZp
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, Ah
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZp
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], Ah
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZp
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], Ah
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZp
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], Ah
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZp
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], Ah
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g2n42_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZ
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZp
   {
      using vertexId1 = Vertex<hh, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g7n47_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], Ah
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g4n44_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZp
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g9n49_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g10n50_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: VWm, conj[VWm], VZp
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t10g10n50_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(
                        TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {Ah, VZp}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Ah, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZp>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {conj[Hpm], VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, typename conj<Hpm>::type, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<typename conj<Hpm>::type>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {Hpm, conj[VWm]}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<hh, Hpm, typename conj<VWm>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_scalar = context.physical_mass<Hpm>(idx_2);
   result.m_vector = context.physical_mass<typename conj<VWm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, typename conj<Hpm>::type, VWm>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// hh -> {VG, VG}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VG, VG>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VG >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VG >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VG>(idx_2);
   result.m_vector_2 = context.physical_mass<VG>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VP}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VP>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_hAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value3(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value2(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)
                     && result.m_decay/mInternal1 < 0.8 && result.m_vector_2/result.m_decay < 0.75
                     ) {
                     const double correction_S = 1 - get_alphas(context)/Pi;
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Hpm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Sd
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Se
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Su
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g2n14_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value3
                     (), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Hpm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Sd
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Se
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Su
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g2n14_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value3
                     (), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value3(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g10n40_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g10n40_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {VP, VZp}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VP, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        odd_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g9n9_VVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g10n10_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Hpm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Sd
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Se
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, Su
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g2n14_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value3
                     (), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Hpm
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Sd
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Se
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, Su
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g1n13_VS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T3
   // internal particles in the diagram: VZp, VWm
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t3g2n14_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value3
                     (), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g2n16_VV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.value1
                     (), 1.0i*vertexId2Val.value3(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g10n40_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g6n36_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWm], gWm
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g8n38_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Se, conj[Se]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Su, conj[Su]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g7n37_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g9n39_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T9
   // internal particles in the diagram: VZp, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t9g10n40_VVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {VZ, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VZ, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, VZ, VZ>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {VZ, VZp}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VZ, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, VZ, VZp>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {VZp, VZp}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, VZp, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<VZp>(idx_2);
   result.m_vector_2 = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<hh, VZp, VZp>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {conj[VWm], VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<hh, typename conj<VWm>::type, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_vector_1 = context.physical_mass<typename conj<VWm>::type>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<hh, typename conj<VWm>::type, VWm>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// hh -> {Glu, Glu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, Glu, Glu>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Glu >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Glu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<Glu>(idx_2);
   result.m_fermion_2 = context.physical_mass<Glu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Sd
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Glu, Sd>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Su
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Glu, Su>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, conj[Sd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId3 = Vertex<Glu, Fd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, conj[Su]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId3 = Vertex<Glu, Fu, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, bar[Fd]
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, bar[Fu]
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// hh -> {Chi, Chi}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, Chi, Chi>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Chi >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Chi >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<Chi>(idx_2);
   result.m_fermion_2 = context.physical_mass<Chi>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Chi, Chi, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fv], Fv}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fv>::type, Fv>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fv >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fv>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fv>::type, Fv, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Cha], Cha}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Cha>::type, Cha>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Cha>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Cha >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Cha>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Cha>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Cha>::type, Cha, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fe], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fe>::type, Fe>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fe>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fe>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fe, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fd], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fd>::type, Fd>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fd>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fd>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fd, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// hh -> {bar[Fu], Fu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<hh, typename bar<Fu>::type, Fu>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<hh>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fu>::type, Fu, hh>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hpm -> {Sd, conj[Su]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Hpm, Sd, typename conj<Su>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Sd >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Su>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sd>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Su>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, Su, typename conj<Sd>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Hpm -> {Se, conj[Sv]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Hpm, Se, typename conj<Sv>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Se >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Sv>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar_1 = context.physical_mass<Se>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sv>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, Sv, typename conj<Se>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Hpm -> {hh, VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Hpm, hh, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<hh, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Hpm -> {Ah, VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Hpm, Ah, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_scalar = context.physical_mass<Ah>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_1, idx_3);
   const auto vertex =  Vertex<Ah, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Hpm -> {VP, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hpm, VP, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, typename conj<VWm>::type, VP>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hpm -> {VZ, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hpm, VZ, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, typename conj<VWm>::type, VZ>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hpm -> {VZp, VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Hpm, VZp, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_vector_1 = context.physical_mass<VZp>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Hpm, typename conj<VWm>::type, VZp>::evaluate(indices, context);

   result.form_factor_g += vertex.value();

   return result;
}

// Hpm -> {Chi, Cha}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hpm, Chi, Cha>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Chi >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Cha >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_fermion_1 = context.physical_mass<Chi>(idx_2);
   result.m_fermion_2 = context.physical_mass<Cha>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Cha>::type, Chi, Hpm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hpm -> {bar[Fv], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hpm, typename bar<Fv>::type, Fe>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fv, Hpm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Hpm -> {bar[Fu], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Hpm, typename bar<Fu>::type, Fd>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Hpm>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fu, Hpm>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {Sd, conj[Sd]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Sd, typename conj<Sd>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Sd >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Sd>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sd>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sd>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Sd, typename conj<Sd>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Sv, conj[Sv]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Sv, typename conj<Sv>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Sv >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Sv>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Sv>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Sv>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Sv, typename conj<Sv>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Su, conj[Su]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Su, typename conj<Su>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Su >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Su>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Su>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Su>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Su, typename conj<Su>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Se, conj[Se]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Se, typename conj<Se>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Se >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Se>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Se>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Se>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Se, typename conj<Se>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {hh, hh}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, hh, hh>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<hh>(idx_2);
   result.m_scalar_2 = context.physical_mass<hh>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, hh>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {Hpm, conj[Hpm]}
template<>
Decay_amplitude_SSS CLASSNAME::calculate_amplitude<Ah, Hpm, typename conj<Hpm>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSS result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar_1 = context.physical_mass<Hpm>(idx_2);
   result.m_scalar_2 = context.physical_mass<typename conj<Hpm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_3, idx_2);
   const auto vertex =  Vertex<Ah, Hpm, typename conj<Hpm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value();

   return result;
}

// Ah -> {hh, VP}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VP>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);

   // FormCalc's Finite variable
   constexpr double Finite {1.};

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(1
                        , 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, hh>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g1n1_FFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.
                        right(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, hh>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, hh>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g3n3_UUU(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), -1.0i*vertexId3Val.value(
                        1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g4n4_SSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<Hpm>::type>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g5n5_SVS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g7n7_SVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, Sd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, Se, typename conj<Se>::type>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, Su, typename conj<Su>::type>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g2n2_SSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value(0
                        , 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g6n6_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t1g8n8_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g2n12_VV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.
                     value3(), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Sd
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Se
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, Su
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g1n11_VS(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T2
   // internal particles in the diagram: VZp, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<0>(indexId2) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t2g2n12_VV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value2(), 1.0i*vertexId2Val.
                     value3(), 1.0i*vertexId2Val.value1(),
                  ren_scale,
                  Finite);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t4g1n15_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SSV_t6g1n18_SV(
                  result.m_decay, result.m_scalar, result.m_vector,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZ, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g10n30_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g6n26_VFF(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.right(), -1.0i*vertexId1Val.left(), -1.0i*vertexId2Val.right
                        (), -1.0i*vertexId2Val.left(), 1.0i*vertexId3Val.value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g7n27_VSS(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g9n29_VSV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T8
   // internal particles in the diagram: VZp, VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<typename conj<VWm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SSV_t8g10n30_VVV(
                     result.m_decay, result.m_scalar, result.m_vector,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(TripleVectorVertex::
                        even_permutation {}), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale,
                     Finite);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {hh, VZ}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZ>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {hh, VZp}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, hh, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::hh >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<hh>(idx_2);
   result.m_vector = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, hh, VZp>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {conj[Hpm], VWm}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, typename conj<Hpm>::type, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::Hpm>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<typename conj<Hpm>::type>(idx_2);
   result.m_vector = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, Hpm, typename conj<VWm>::type>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {Hpm, conj[VWm]}
template<>
Decay_amplitude_SSV CLASSNAME::calculate_amplitude<Ah, Hpm, typename conj<VWm>::type>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Hpm >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SSV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_scalar = context.physical_mass<Hpm>(idx_2);
   result.m_vector = context.physical_mass<typename conj<VWm>::type>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_1, idx_2, idx_3);
   const auto vertex =  Vertex<Ah, typename conj<Hpm>::type, VWm>::evaluate(indices, context);

   result.form_factor += vertex.value(0, 1);

   return result;
}

// Ah -> {VG, VG}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VG, VG>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VG >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VG >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VG>(idx_2);
   result.m_vector_2 = context.physical_mass<VG>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VG>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VG>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VG>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VG, VG>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {4.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VP}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VP>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VP>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<0>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<1>(indexId3) == vertexId3::template indices_of_field<0>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                           value(1, 0),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  auto temp_result = symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<0>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                     vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     const auto correction_S = 1. + get_alphas(context)/Pi * delta_hAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     const auto correction_P = 1. + get_alphas(context)/Pi * delta_AhAA_2loopQCD_for_quark_loop(result.m_decay, mInternal1, ren_scale);
                     temp_result.form_factor_g   = correction_S * temp_result.form_factor_g;
                     temp_result.form_factor_11  = correction_S * temp_result.form_factor_11;
                     temp_result.form_factor_12  = correction_S * temp_result.form_factor_12;
                     temp_result.form_factor_21  = correction_S * temp_result.form_factor_21;
                     temp_result.form_factor_22  = correction_S * temp_result.form_factor_22;
                     temp_result.form_factor_eps = correction_P * temp_result.form_factor_eps;
                  }
                  result += temp_result;
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};


                  if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                     vertexId1::template indices_of_field<1>(indexId1) == vertexId1::template indices_of_field<2>(indexId1) &&
                     vertexId2::template indices_of_field<1>(indexId2) == vertexId2::template indices_of_field<0>(indexId2) &&
                     vertexId3::template indices_of_field<0>(indexId3) == vertexId3::template indices_of_field<1>(indexId3)) {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
                  }
                  else {
                     result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                        result.m_decay, result.m_vector_1, result.m_vector_2,
                        mInternal1, mInternal2, mInternal3, 
                        1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                           value(0, 1),
                        ren_scale);
                  }
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VP>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};


               if (static_cast<int>(flexibledecay_settings.get(FlexibleDecay_settings::include_higher_order_corrections)) > 0 &&
                  vertexId1::template indices_of_field<2>(indexId1) == vertexId1::template indices_of_field<1>(indexId1) &&
                  vertexId2::template indices_of_field<0>(indexId2) == vertexId2::template indices_of_field<1>(indexId2)) {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale) * (1. + get_alphas(context)/Pi * 1.333333333333333 * delta_AhAA_2loopQCD_for_squark_loop(result.m_decay, mInternal1, ren_scale));
               }
               else {
                  result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VP, VZp}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VP, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VP >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VP>(idx_2);
   result.m_vector_2 = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   return result;
}

// Ah -> {VZ, VZ}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VZ, VZ>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZ>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, VZ>;
      using vertexId3 = Vertex<Chi, Chi, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fv, bar[Fv], Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Sv
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fv], Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sv, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZ>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], hh
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], hh
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {VZ, VZp}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VZ, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZ >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VZ>(idx_2);
   result.m_vector_2 = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, VZp>;
      using vertexId3 = Vertex<Chi, Chi, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fv, bar[Fv], Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Sv
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fv], Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sv, hh
   {
      using vertexId1 = Vertex<hh, VZ, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], hh
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], hh
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {VZp, VZp}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, VZp, VZp>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VZp >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<VZp>(idx_2);
   result.m_vector_2 = context.physical_mass<VZp>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Cha, bar[Cha], Cha
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Chi
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Chi, VZp>;
      using vertexId3 = Vertex<Chi, Chi, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fe, bar[Fe], Fe
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fv, bar[Fv], Fv
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fv>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gWm]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWmC], gWmC, bar[gWmC]
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Ah
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<Ah, hh, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZ
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<hh, VZ, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VZp
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Sd
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZp>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Se, conj[Se], Se
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZp>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Su
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZp>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Sv
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZp>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sv>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, bar[Cha]
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Cha, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fd, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fe]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fe, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Fu, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fv], Fv, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId3 = Vertex<typename bar<Fv>::type, Fv, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWm, bar[gWm], gWm
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gWmC
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gWmC>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], Hpm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Hpm, conj[VWm], VWm
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZp>;
      using vertexId3 = Vertex<Sd, typename conj<Sd>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZp>;
      using vertexId3 = Vertex<Se, typename conj<Se>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZp>;
      using vertexId3 = Vertex<Su, typename conj<Su>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sv], Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZp>;
      using vertexId3 = Vertex<Sv, typename conj<Sv>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], Hpm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VWm, conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sv, hh
   {
      using vertexId1 = Vertex<hh, VZp, VZp>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<3>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: Hpm, conj[VWm]
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VWm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VWm
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], hh
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId3 = Vertex<hh, VZp, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], hh
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {conj[VWm], VWm}
template<>
Decay_amplitude_SVV CLASSNAME::calculate_amplitude<Ah, typename conj<VWm>::type, VWm>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::conj<fields::VWm>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::VWm >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SVV result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_vector_1 = context.physical_mass<typename conj<VWm>::type>(idx_2);
   result.m_vector_2 = context.physical_mass<VWm>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_g = std::complex<double>(0., 0.);
   result.form_factor_11 = std::complex<double>(0., 0.);
   result.form_factor_12 = std::complex<double>(0., 0.);
   result.form_factor_21 = std::complex<double>(0., 0.);
   result.form_factor_22 = std::complex<double>(0., 0.);
   result.form_factor_eps = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Ah, Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Ah, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Cha], Cha, Chi
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId2 = Vertex<Chi, Cha, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Chi, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Chi, Chi, Cha
   {
      using vertexId1 = Vertex<Chi, Chi, Ah>;
      using vertexId2 = Vertex<Chi, Cha, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Cha>::type, Chi, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Cha>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, bar[Fu]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fd, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fu, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fe], Fe, bar[Fv]
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fv, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), -1.0i*vertexId2Val.right()
                        , -1.0i*vertexId2Val.left(), -1.0i*vertexId3Val.right(), -1.0i*vertexId3Val.
                        left(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gP]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gP>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gP>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gZ]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gZ>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gZ, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gZ>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[gWm], gWm, bar[gZp]
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gZp>::type, gWm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gZp, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gZp>::type>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, Ah, Hpm
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZ, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZp, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Hpm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: hh, VZp, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, Ah
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], Hpm, VZp
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g4n4_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<Hpm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g5n5_SVS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Hpm], VWm, VZp
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<1>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g7n7_SVV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Su, typename conj<Sd>::type, VWm>;
      using vertexId3 = Vertex<Sd, typename conj<Su>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Se], Se, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Se>::type, VWm>;
      using vertexId3 = Vertex<Se, typename conj<Sv>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(1, 0), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, VP
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[VWm], Hpm, VZp
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZ, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZp, hh, Hpm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, Hpm, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g6n6_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val
                        .value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: VZp, hh, VWm
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId2::template indices_of_field<2>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g8n8_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Fd
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fd, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Fu, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fv, bar[Fv], Fe
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fe, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<Fe>::type, Fv, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Fe>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g1n1_FFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gP
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gP, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gP>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gP>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gZ, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gZ>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gZ>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: gWmC, bar[gWmC], gZp
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gZp, typename conj<VWm>::type>;
      using vertexId3 = Vertex<typename bar<gZp>::type, gWmC, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<gZp>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g3n3_UUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), -1.0i*vertexId3Val.
                        value(1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Sd
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Sd>::type, VWm>;
      using vertexId3 = Vertex<Sd, typename conj<Su>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sv, conj[Sv], Se
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Se>::type, VWm>;
      using vertexId3 = Vertex<Se, typename conj<Sv>::type, typename conj<VWm>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<2>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<Se>::type>(vertexId2::template indices_of_field<1>(indexId2))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t1g2n2_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(1, 0),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Ah, Ah
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<Ah, Ah, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
               const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Hpm, conj[Hpm]
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sd, conj[Sd]
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Se, conj[Se]
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Su, conj[Su]
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T4
   // internal particles in the diagram: Sv, conj[Sv]
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t4g1n15_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Hpm, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Hpm>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sd, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Se, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Se>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Su, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T5
   // internal particles in the diagram: Sv, hh
   {
      using vertexId1 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId2 = Vertex<Ah, hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId2::template indices_of_field<2>(indexId2) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<Sv>(vertexId2::template indices_of_field<2>(indexId2))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t5g1n17_SS(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, VP
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VP>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<2>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VP>(vertexId1::template indices_of_field<1>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, VZ
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T6
   // internal particles in the diagram: Hpm, VZp
   {
      using vertexId1 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId2 = Vertex<Ah, Hpm, typename conj<VWm>::type, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<2>(indexId2);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t6g1n19_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VP
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VP, VWm>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<3>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VZ
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZ>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T7
   // internal particles in the diagram: conj[Hpm], VZp
   {
      using vertexId1 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId2 = Vertex<Ah, typename conj<Hpm>::type, VWm, VZp>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {

            // skip indices that don't match external indices
            const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<0>(indexId2);
            const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<1>(indexId1);

            if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
               continue;

            // connect internal particles in vertices
            if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
               continue;

            if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<3>(indexId2))
               continue;

            auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
            auto const vertexId2Val = vertexId2::evaluate(indexId2, context);

            if (!vertexId1Val.isZero() && !vertexId2Val.isZero()) {
               // internal masses
               const double mInternal1 {context.mass<Hpm>(vertexId1::template indices_of_field<0>(indexId1))};
               const double mInternal2 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};

               result += symmetryFac * colorFac * calculate_diagram_SVV_t7g1n20_SV(
                  result.m_decay, result.m_vector_1, result.m_vector_2,
                  mInternal1, mInternal2, 
                  1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(),
                  ren_scale);
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, Ah, hh
   {
      using vertexId1 = Vertex<Ah, Ah, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Ah, Ah, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<Ah>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, hh
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<Ah, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZ
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Ah, hh, VZp
   {
      using vertexId1 = Vertex<Ah, Ah, hh>;
      using vertexId2 = Vertex<Ah, hh, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Ah>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], hh
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, hh>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VP
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VP>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZ
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZ>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Cha, bar[Cha], VZp
   {
      using vertexId1 = Vertex<typename bar<Cha>::type, Cha, VZp>;
      using vertexId2 = Vertex<typename bar<Cha>::type, Cha, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Cha>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Cha>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, hh
   {
      using vertexId1 = Vertex<Chi, Chi, hh>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZ
   {
      using vertexId1 = Vertex<Chi, Chi, VZ>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Chi, Chi, VZp
   {
      using vertexId1 = Vertex<Chi, Chi, VZp>;
      using vertexId2 = Vertex<Chi, Chi, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Chi>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal3 {context.mass<Chi>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.right(), 1.0i*vertexId1Val.left(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], hh
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, hh>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VP
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VP>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZ
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZ>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fd, bar[Fd], VZp
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Fd, VZp>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], hh
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, hh>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VP
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VP>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZ
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZ>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fe, bar[Fe], VZp
   {
      using vertexId1 = Vertex<typename bar<Fe>::type, Fe, VZp>;
      using vertexId2 = Vertex<typename bar<Fe>::type, Fe, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fe>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fe>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], hh
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, hh>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VP
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VP>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZ
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZ>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fu, bar[Fu], VZp
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Fu, VZp>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], hh
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, hh>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId3 = Vertex<hh, typename conj<VWm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g1n41_SFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], VZ
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZ>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Fv, bar[Fv], VZp
   {
      using vertexId1 = Vertex<typename bar<Fv>::type, Fv, VZp>;
      using vertexId2 = Vertex<typename bar<Fv>::type, Fv, Ah>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Fv>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<Fv>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g6n46_VFF(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     -1.0i*vertexId1Val.left(), -1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left()
                        , 1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(TripleVectorVertex::
                        even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, hh
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename bar<gWm>::type, gWm, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VP
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZ
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWm], gWm, VZp
   {
      using vertexId1 = Vertex<typename bar<gWm>::type, gWm, Ah>;
      using vertexId2 = Vertex<typename bar<gWm>::type, gWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWm>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, hh
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<typename bar<gWmC>::type, gWmC, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g3n43_SUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VP
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZ
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: bar[gWmC], gWmC, VZp
   {
      using vertexId1 = Vertex<typename bar<gWmC>::type, gWmC, Ah>;
      using vertexId2 = Vertex<typename bar<gWmC>::type, gWmC, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<2>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<gWmC>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename bar<gWmC>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g8n48_VUU(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), -1.0i*vertexId2Val.value(1), 1.0i*vertexId3Val.value
                        (TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, hh, hh
   {
      using vertexId1 = Vertex<Ah, hh, hh>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, hh, hh>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<hh>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZ
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, VZ, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZ, VZp
   {
      using vertexId1 = Vertex<Ah, hh, VZ>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZ>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZp, VZ
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, VZ, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: hh, VZp, VZp
   {
      using vertexId1 = Vertex<Ah, hh, VZp>;
      using vertexId2 = Vertex<hh, VZp, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<hh>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VZp>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<Hpm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[Hpm], VZp
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<Hpm>::type>;
      using vertexId2 = Vertex<Hpm, typename conj<Hpm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, hh
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, typename conj<Hpm>::type, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VP
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VP, VWm>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<2>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZ
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: conj[Hpm], VWm, VZp
   {
      using vertexId1 = Vertex<Ah, Hpm, typename conj<VWm>::type>;
      using vertexId2 = Vertex<typename conj<Hpm>::type, VWm, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<Hpm>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<typename conj<VWm>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], hh
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VP
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZ
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sd, conj[Sd], VZp
   {
      using vertexId1 = Vertex<Ah, Sd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<Sd, typename conj<Sd>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], hh
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Se, typename conj<Se>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VP
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZ
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Se, conj[Se], VZp
   {
      using vertexId1 = Vertex<Ah, Se, typename conj<Se>::type>;
      using vertexId2 = Vertex<Se, typename conj<Se>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Se>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Se>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], hh
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VP
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZ
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Su, conj[Su], VZp
   {
      using vertexId1 = Vertex<Ah, Su, typename conj<Su>::type>;
      using vertexId2 = Vertex<Su, typename conj<Su>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {3.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], hh
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Sv, typename conj<Sv>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g2n42_SSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.value()
                        ,
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZ
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Sv, conj[Sv], VZp
   {
      using vertexId1 = Vertex<Ah, Sv, typename conj<Sv>::type>;
      using vertexId2 = Vertex<Sv, typename conj<Sv>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Sv>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal3 {context.mass<Sv>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g7n47_VSS(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(), 1.0i*vertexId2Val.value(0, 1), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], hh
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<hh, typename conj<VWm>::type, VWm>;
      using vertexId3 = Vertex<hh, Hpm, typename conj<VWm>::type>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<hh>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g4n44_SSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(0, 1),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VP
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VP>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VP, VWm>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<2>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VP>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::odd_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZ
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZ>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZ>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZ>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T10
   // internal particles in the diagram: Hpm, conj[VWm], VZp
   {
      using vertexId1 = Vertex<Ah, typename conj<Hpm>::type, VWm>;
      using vertexId2 = Vertex<Hpm, typename conj<VWm>::type, VZp>;
      using vertexId3 = Vertex<typename conj<VWm>::type, VWm, VZp>;

      constexpr double symmetryFac {2.000000000000000};

      constexpr double colorFac {1.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn2 = vertexId3::template indices_of_field<1>(indexId3);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<VZp>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal2 {context.mass<typename conj<Hpm>::type>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal3 {context.mass<VWm>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SVV_t10g9n49_VSV(
                     result.m_decay, result.m_vector_1, result.m_vector_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.value(0, 1), 1.0i*vertexId2Val.value(), 1.0i*vertexId3Val.
                        value(TripleVectorVertex::even_permutation {}),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {Glu, Glu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, Glu, Glu>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Glu >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Glu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<Glu>(idx_2);
   result.m_fermion_2 = context.physical_mass<Glu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);

   const double ren_scale {result.m_decay};

   // ----------------- 1-loop contributions to the amplitude -----------------

   // topology T1
   // internal particles in the diagram: Fd, bar[Fd], Sd
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<typename bar<Fd>::type, Glu, Sd>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fd>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Fu, bar[Fu], Su
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<typename bar<Fu>::type, Glu, Su>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<1>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<1>(indexId2) != vertexId3::template indices_of_field<0>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};
                  const double mInternal2 {context.mass<Fu>(vertexId2::template indices_of_field<1>(indexId2))};
                  const double mInternal3 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Sd, conj[Sd], Fd
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Sd>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: Su, conj[Su], Fu
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<0>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<typename conj<Su>::type>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fd], Fd, conj[Sd]
   {
      using vertexId1 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Fd, Ah>;
      using vertexId3 = Vertex<Glu, Fd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fd>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fd>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Sd>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: bar[Fu], Fu, conj[Su]
   {
      using vertexId1 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Fu, Ah>;
      using vertexId3 = Vertex<Glu, Fu, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId2::template indices_of_field<2>(indexId2);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId3::template indices_of_field<0>(indexId3);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<0>(indexId1) != vertexId2::template indices_of_field<1>(indexId2))
                  continue;

               if (vertexId2::template indices_of_field<0>(indexId2) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename bar<Fu>::type>(vertexId1::template indices_of_field<0>(indexId1))};
                  const double mInternal2 {context.mass<typename bar<Fu>::type>(vertexId2::template indices_of_field<0>(indexId2))};
                  const double mInternal3 {context.mass<Su>(vertexId1::template indices_of_field<2>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g1n1_FFS(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.left(), 1.0i*vertexId3Val.right
                        (),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Sd], Sd, bar[Fd]
   {
      using vertexId1 = Vertex<Glu, Fd, typename conj<Sd>::type>;
      using vertexId2 = Vertex<typename bar<Fd>::type, Glu, Sd>;
      using vertexId3 = Vertex<Ah, Sd, typename conj<Sd>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Sd>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Sd>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fd>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   // topology T1
   // internal particles in the diagram: conj[Su], Su, bar[Fu]
   {
      using vertexId1 = Vertex<Glu, Fu, typename conj<Su>::type>;
      using vertexId2 = Vertex<typename bar<Fu>::type, Glu, Su>;
      using vertexId3 = Vertex<Ah, Su, typename conj<Su>::type>;

      constexpr double symmetryFac {1.000000000000000};

      constexpr double colorFac {2.000000000000000};

      // loops over vertices' indices
      for (const auto& indexId1: index_range<vertexId1>()) {
         for (const auto& indexId2: index_range<vertexId2>()) {
            for (const auto& indexId3: index_range<vertexId3>()) {

               // skip indices that don't match external indices
               const auto externalFieldIndicesIn1 = vertexId3::template indices_of_field<0>(indexId3);
               const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<0>(indexId1);
               const auto externalFieldIndicesIn3 = vertexId2::template indices_of_field<1>(indexId2);

               if (externalFieldIndicesIn1 != idx_1 || externalFieldIndicesIn2 != idx_2 || externalFieldIndicesIn3 != idx_3)
                  continue;

               // connect internal particles in vertices
               if (vertexId1::template indices_of_field<2>(indexId1) != vertexId3::template indices_of_field<1>(indexId3))
                  continue;

               if (vertexId2::template indices_of_field<2>(indexId2) != vertexId3::template indices_of_field<2>(indexId3))
                  continue;

               if (vertexId1::template indices_of_field<1>(indexId1) != vertexId2::template indices_of_field<0>(indexId2))
                  continue;

               auto const vertexId1Val = vertexId1::evaluate(indexId1, context);
               auto const vertexId2Val = vertexId2::evaluate(indexId2, context);
               auto const vertexId3Val = vertexId3::evaluate(indexId3, context);

               if (!vertexId1Val.isZero() && !vertexId2Val.isZero() && !vertexId3Val.isZero()) {
                  // internal masses
                  const double mInternal1 {context.mass<typename conj<Su>::type>(vertexId1::template indices_of_field<2>(indexId1))};
                  const double mInternal2 {context.mass<Su>(vertexId2::template indices_of_field<2>(indexId2))};
                  const double mInternal3 {context.mass<Fu>(vertexId1::template indices_of_field<1>(indexId1))};

                  result += symmetryFac * colorFac * calculate_diagram_SFF_t1g2n2_SSF(
                     result.m_decay, result.m_fermion_1, result.m_fermion_2,
                     mInternal1, mInternal2, mInternal3, 
                     1.0i*vertexId1Val.left(), 1.0i*vertexId1Val.right(), 1.0i*vertexId2Val.left(),
                        1.0i*vertexId2Val.right(), 1.0i*vertexId3Val.value(),
                     ren_scale);
               }
            }
         }
      }
   }

   return result;
}

// Ah -> {Chi, Chi}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, Chi, Chi>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<fields::Chi >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Chi >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<Chi>(idx_2);
   result.m_fermion_2 = context.physical_mass<Chi>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_2, idx_3, idx_1);
   const auto vertex =  Vertex<Chi, Chi, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fv], Fv}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fv>::type, Fv>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fv>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fv >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fv>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fv>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fv>::type, Fv, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Cha], Cha}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Cha>::type, Cha>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Cha>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Cha >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Cha>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Cha>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Cha>::type, Cha, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fe], Fe}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fe>::type, Fe>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fe>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fe >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fe>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fe>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fe>::type, Fe, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fd], Fd}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fd>::type, Fd>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fd>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fd >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fd>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fd>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fd>::type, Fd, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}

// Ah -> {bar[Fu], Fu}
template<>
Decay_amplitude_SFF CLASSNAME::calculate_amplitude<Ah, typename bar<Fu>::type, Fu>(
   const context_base& context,
   typename UMSSM_cxx_diagrams::field_indices<fields::Ah >::type const& idx_1,
   typename UMSSM_cxx_diagrams::field_indices<typename fields::bar<fields::Fu>::type >::type const& idx_2,
   typename UMSSM_cxx_diagrams::field_indices<fields::Fu >::type const& idx_3) const{
   
   // amplitude type
   Decay_amplitude_SFF result;

   // external particles' masses
   result.m_decay = context.physical_mass<Ah>(idx_1);
   result.m_fermion_1 = context.physical_mass<typename bar<Fu>::type>(idx_2);
   result.m_fermion_2 = context.physical_mass<Fu>(idx_3);

   // set the initial value of an amplitude to 0
   result.form_factor_left = std::complex<double>(0., 0.);
   result.form_factor_right = std::complex<double>(0., 0.);
   // @todo correct prefactors
   // tree-level amplitude
   const auto indices = concatenate(idx_3, idx_2, idx_1);
   const auto vertex =  Vertex<typename bar<Fu>::type, Fu, Ah>::evaluate(indices, context);

   result.form_factor_left += vertex.left();
   result.form_factor_right += vertex.right();

   return result;
}


// -------- specializations for decays needing higher order SM corrections --------

using H = fields::hh;
using AH = fields::Ah;
using W = fields::VWm;
using Z = fields::VZ;
using G = fields::VG;
using A = fields::VP;
using lep = fields::Fe;
using uq = fields::Fu;
using dq = fields::Fd;

// List of potential Z boson decay products excluding pure SM decays
typedef boost::mpl::list<
   boost::mpl::list<fields::Ah, fields::hh>,
   boost::mpl::list<fields::Cha, typename fields::bar<fields::Cha>::type>,
   boost::mpl::list<fields::Chi, fields::Chi>,
   boost::mpl::list<fields::hh, fields::Ah>,
   boost::mpl::list<fields::hh, fields::VZp>,
   boost::mpl::list<fields::Hpm, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<fields::Sd, typename fields::conj<fields::Sd>::type>,
   boost::mpl::list<fields::Se, typename fields::conj<fields::Se>::type>,
   boost::mpl::list<fields::Su, typename fields::conj<fields::Su>::type>,
   boost::mpl::list<fields::Sv, typename fields::conj<fields::Sv>::type>,
   boost::mpl::list<fields::VZp, fields::hh>,
   boost::mpl::list<typename fields::bar<fields::Cha>::type, fields::Cha>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::Hpm>,
   boost::mpl::list<typename fields::conj<fields::Sd>::type, fields::Sd>,
   boost::mpl::list<typename fields::conj<fields::Se>::type, fields::Se>,
   boost::mpl::list<typename fields::conj<fields::Su>::type, fields::Su>,
   boost::mpl::list<typename fields::conj<fields::Sv>::type, fields::Sv>,
   boost::mpl::list<fields::hh, fields::VZ>,
   boost::mpl::list<fields::Hpm, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VWm>
> BSMForZdecay;

// List of potential W boson decay products excluding pure SM decays
typedef boost::mpl::list<
   boost::mpl::list<fields::Ah, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<fields::Chi, typename fields::bar<fields::Cha>::type>,
   boost::mpl::list<fields::hh, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<fields::Su, typename fields::conj<fields::Sd>::type>,
   boost::mpl::list<fields::Sv, typename fields::conj<fields::Se>::type>,
   boost::mpl::list<fields::VZp, typename fields::conj<fields::Hpm>::type>,
   boost::mpl::list<typename fields::bar<fields::Cha>::type, fields::Chi>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::Ah>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::hh>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VZp>,
   boost::mpl::list<typename fields::conj<fields::Sd>::type, fields::Su>,
   boost::mpl::list<typename fields::conj<fields::Se>::type, fields::Sv>,
   boost::mpl::list<fields::hh, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<fields::VZp, typename fields::conj<fields::VWm>::type>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VP>,
   boost::mpl::list<typename fields::conj<fields::Hpm>::type, fields::VZ>
> BSMForWdecay;

template <typename DecayProds, typename V>
bool check_3body_Vff_decay(const context_base& context, double  mHOS, const typename field_indices<V>::type& idx)  {
   bool found_problem = false;
   const double mVOS {context.physical_mass<V>(idx)};
   boost::mpl::for_each<DecayProds>(
      [mHOS, mVOS, &idx, &context, &found_problem](auto arg) {
         using T = decltype(arg);
         using Field1 = typename boost::mpl::at<T, boost::mpl::int_<0>>::type;
         using Field2 = typename boost::mpl::at<T, boost::mpl::int_<1>>::type;
         using vertexId1 = Vertex<V, Field1, Field2>;
         for (const auto& indexId1: index_range<vertexId1>()) {
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            if (externalFieldIndicesIn1 != idx) {
               continue;
            }
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            const double mInternal2 {context.physical_mass<Field1>(externalFieldIndicesIn2)};
            const double mInternal3 {context.physical_mass<Field2>(externalFieldIndicesIn3)};

            if (mHOS-mVOS > mInternal2 + mInternal3
                && !Vertex<V, Field1, Field2>::evaluate(indexId1, context).isZero()) {
               found_problem = true;
            }
         }
      }
   );
   return found_problem;
}

#include "decays/H_SM_decays/decay_H_to_ZZ.inc"
#include "decays/H_SM_decays/decay_H_to_WW.inc"
#include "decays/H_SM_decays/decay_H_to_GG.inc"
#include "decays/H_SM_decays/decay_H_to_AA.inc"
#include "decays/H_SM_decays/decay_H_to_AZ.inc"
#include "decays/H_SM_decays/decay_H_to_uquq.inc"
#include "decays/H_SM_decays/decay_H_to_dqdq.inc"
#include "decays/H_SM_decays/decay_H_to_leplep.inc"
#include "decays/H_SM_decays/decay_AH_to_dqdq.inc"
#include "decays/H_SM_decays/decay_AH_to_uquq.inc"
#include "decays/H_SM_decays/decay_AH_to_GG.inc"
#include "decays/H_SM_decays/decay_AH_to_AA.inc"
#include "decays/H_SM_decays/decay_AH_to_AZ.inc"
#include "decays/H_SM_decays/decay_AH_to_leplep.inc"

void CLASSNAME::calculate_hh_decays()
{

   for (int gI1 = 0; gI1 < 3; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(Mhh);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         UMSSM_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  UMSSM_mass_eigenstates_decoupling_scheme>(model.get_input());
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(Mhh);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<UMSSM_mass_eigenstates>(model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_hh_decays(gI1);

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sd>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sd>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SdconjSd(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sd
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sd,
               gO2)}, create_process_string<hh, Sd, typename conj<Sd>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sv>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sv>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SvconjSv(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sv
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sv,
               gO2)}, create_process_string<hh, Sv, typename conj<Sv>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Su>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Su>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SuconjSu(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Su
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Su,
               gO2)}, create_process_string<hh, Su, typename conj<Su>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Se>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Se>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_SeconjSe(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Se
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Se,
               gO2)}, create_process_string<hh, Se, typename conj<Se>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (gI1 == gO2) {
               continue;
            }
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<hh>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_hhhh(dec_model.get(), gI1, gO1
               , gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh,
               gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO2)
               }, create_process_string<hh, hh, hh>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 2; gO2 < 3; ++gO2) {
            if (gI1 == gO1) {
               continue;
            }
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_hhAh(dec_model.get(), gI1, gO1
               , gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh,
               gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah, gO2)
               }, create_process_string<hh, hh, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 2; gO1 < 3; ++gO1) {
         for (int gO2 = 2; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Ah>(std::array<int, 1> {gO1}) + context.
               physical_mass<Ah>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_AhAh(dec_model.get(), gI1, gO1
               , gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah,
               gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah, gO2)
               }, create_process_string<hh, Ah, Ah>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO2}
               )) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_HpmconjHpm(dec_model.get(),
               gI1, gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(
               UMSSM_info::Hpm, gO1), -UMSSM_info::get_pdg_code_for_particle(
               UMSSM_info::Hpm, gO2)}, create_process_string<hh, Hpm, typename
               conj<Hpm>::type>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVP(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP)},
            create_process_string<hh, hh, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 2; gO1 < 3; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVP(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP)},
            create_process_string<hh, Ah, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVZ(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ)},
            create_process_string<hh, hh, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 2; gO1 < 3; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVZ(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ)},
            create_process_string<hh, Ah, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (gI1 == gO1) {
            continue;
         }
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZp>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_hhVZp(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZp)},
            create_process_string<hh, hh, VZp>({gI1},{gO1},{}));

      }

      for (int gO1 = 2; gO1 < 3; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZp>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_AhVZp(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZp)},
            create_process_string<hh, Ah, VZp>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO1}) +
            context.physical_mass<VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_conjHpmVWm(dec_model.get(), gI1,
            gO1), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Hpm, gO1)
            , UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<hh, typename conj<Hpm>::type, VWm>({gI1},{gO1
            },{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
            physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
            physical_mass<typename conj<VWm>::type>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_hh_to_HpmconjVWm(dec_model.get(), gI1,
            gO1), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Hpm, gO1),
            -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<hh, Hpm, typename conj<VWm>::type>({gI1},{gO1
            },{}));

      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VG>(std::array<int, 0> {}) + context.physical_mass<VG>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VGVG(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VG), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VG)}, create_process_string<
            hh, VG, VG>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VP>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVP(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VP)}, create_process_string<
            hh, VP, VP>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVZ(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZ)}, create_process_string<
            hh, VP, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZp>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VPVZp(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZp)}, create_process_string<
            hh, VP, VZp>({gI1},{},{}));
      }
         decays.set_decay(partial_width_hh_to_VZVZ(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZ)}, create_process_string<
            hh, VZ, VZ>({gI1},{},{}));

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VZp>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VZVZp(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZp)}, create_process_string<
            hh, VZ, VZp>({gI1},{},{}));
      }

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZp>(std::array<int, 0> {}) + context.physical_mass<VZp>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_VZpVZp(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZp), UMSSM_info
            ::get_pdg_code_for_particle(UMSSM_info::VZp)},
            create_process_string<hh, VZp, VZp>({gI1},{},{}));
      }
         decays.set_decay(partial_width_hh_to_conjVWmVWm(dec_model.get(), gI1),
            {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<hh, typename conj<VWm>::type, VWm>({gI1},{},{
            }));

      if (context.physical_mass<hh>(std::array<int, 1>{gI1}) > context.
         physical_mass<Glu>(std::array<int, 0> {}) + context.physical_mass<Glu>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_hh_to_GluGlu(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Glu), UMSSM_info
            ::get_pdg_code_for_particle(UMSSM_info::Glu)},
            create_process_string<hh, Glu, Glu>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<Chi>(std::array<int, 1> {gO1}) + context.
               physical_mass<Chi>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_ChiChi(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Chi, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Chi
               , gO2)}, create_process_string<hh, Chi, Chi>({gI1},{gO1},{gO2}))
               ;

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fv>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFvFv(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fv, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fv,
               gO2)}, create_process_string<hh, typename bar<Fv>::type, Fv>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Cha>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Cha>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barChaCha(dec_model.get(), gI1
               , gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info
               ::Cha, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Cha, gO2)}, create_process_string<hh, typename bar<Cha>::type,
               Cha>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fe>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFeFe(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fe, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fe,
               gO2)}, create_process_string<hh, typename bar<Fe>::type, Fe>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fd>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFdFd(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fd, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fd,
               gO2)}, create_process_string<hh, typename bar<Fd>::type, Fd>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<hh>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fu>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_hh_to_barFuFu(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fu, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fu,
               gO2)}, create_process_string<hh, typename bar<Fu>::type, Fu>({
               gI1},{gO1},{gO2}));

         }
      }

   }


}

void CLASSNAME::calculate_Hpm_decays()
{

   for (int gI1 = 1; gI1 < 2; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(MHpm);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         UMSSM_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  UMSSM_mass_eigenstates_decoupling_scheme>(model.get_input());
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(MHpm);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<UMSSM_mass_eigenstates>(model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_Hpm_decays(gI1);

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sd>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Su>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_SdconjSu(dec_model.get(), gI1
               , gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Sd, gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Su,
               gO2)}, create_process_string<Hpm, Sd, typename conj<Su>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<Se>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sv>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_SeconjSv(dec_model.get(), gI1
               , gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Se, gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sv,
               gO2)}, create_process_string<Hpm, Se, typename conj<Sv>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Hpm_to_hhVWm(dec_model.get(), gI1, gO1)
            , {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<Hpm, hh, VWm>({gI1},{gO1},{}));

      }

      for (int gO1 = 2; gO1 < 3; ++gO1) {
         if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
            physical_mass<Ah>(std::array<int, 1> {gO1}) + context.physical_mass
            <VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Hpm_to_AhVWm(dec_model.get(), gI1, gO1)
            , {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Ah, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<Hpm, Ah, VWm>({gI1},{gO1},{}));

      }

      if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VWm>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hpm_to_VPVWm(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VWm)}, create_process_string<
            Hpm, VP, VWm>({gI1},{},{}));
      }

      if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VWm>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hpm_to_VZVWm(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VWm)}, create_process_string<
            Hpm, VZ, VWm>({gI1},{},{}));
      }

      if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZp>(std::array<int, 0> {}) + context.physical_mass<VWm>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_Hpm_to_VZpVWm(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZp), UMSSM_info
            ::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<Hpm, VZp, VWm>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<Chi>(std::array<int, 1> {gO1}) + context.
               physical_mass<Cha>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_ChiCha(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Chi, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Cha
               , gO2)}, create_process_string<Hpm, Chi, Cha>({gI1},{gO1},{gO2})
               );

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_barFvFe(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fv, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fe,
               gO2)}, create_process_string<Hpm, typename bar<Fv>::type, Fe>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Hpm>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Hpm_to_barFuFd(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fu, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fd,
               gO2)}, create_process_string<Hpm, typename bar<Fu>::type, Fd>({
               gI1},{gO1},{gO2}));

         }
      }

   }


}

void CLASSNAME::calculate_Ah_decays()
{

   for (int gI1 = 2; gI1 < 3; ++gI1) {

      if (run_to_decay_particle_scale) {
         auto decay_mass = PHYSICAL(MAh);
         if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
            model.run_to(decay_mass(gI1));
            model.solve_ewsb();
         }
      }

      const int flag = 1;
      auto dec_model = [&] () -> std::unique_ptr<
         UMSSM_mass_eigenstates_interface> {
         switch (flag) {
            case 1: {
               auto dm = std::make_unique<
                  UMSSM_mass_eigenstates_decoupling_scheme>(model.get_input());
               // fill_from BSM model has to be called before fill_from SM
               // both calls are required
               dm->fill_from(model);
               standard_model::Standard_model sm{};
               sm.initialise_from_input(qedqcd);
               // set loop level for RGE running to match RGE setting
               // of BSM model
               sm.set_loops(model.get_loops());
               if (run_to_decay_particle_scale) {
                  auto decay_mass = PHYSICAL(MAh);
                  if (decay_mass(gI1) > qedqcd.displayPoleMZ()) {
                     sm.run_to(decay_mass(gI1));
                  }
               }
               sm.solve_ewsb_tree_level();
               sm.calculate_DRbar_masses();
               dm->fill_from(sm);
               return dm;
               break;
            }
            case 2:
               return std::make_unique<UMSSM_mass_eigenstates>(model);
               break;
            default:
               throw SetupError("flag value is not supported");
         }
      }();

      context_base context {dec_model.get()};

      auto& decays = decay_table.get_Ah_decays(gI1);

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sd>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sd>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SdconjSd(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sd
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sd,
               gO2)}, create_process_string<Ah, Sd, typename conj<Sd>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Sv>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Sv>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SvconjSv(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sv
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Sv,
               gO2)}, create_process_string<Ah, Sv, typename conj<Sv>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Su>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Su>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SuconjSu(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Su
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Su,
               gO2)}, create_process_string<Ah, Su, typename conj<Su>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Se>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Se>::type>(std::array<int, 1> {gO2})
               ) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_SeconjSe(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Se
               , gO1), -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Se,
               gO2)}, create_process_string<Ah, Se, typename conj<Se>::type>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<hh>(std::array<int, 1> {gO1}) + context.
               physical_mass<hh>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_hhhh(dec_model.get(), gI1, gO1
               , gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh,
               gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO2)
               }, create_process_string<Ah, hh, hh>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         for (int gO2 = 1; gO2 < 2; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
               physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO2}
               )) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_HpmconjHpm(dec_model.get(),
               gI1, gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(
               UMSSM_info::Hpm, gO1), -UMSSM_info::get_pdg_code_for_particle(
               UMSSM_info::Hpm, gO2)}, create_process_string<Ah, Hpm, typename
               conj<Hpm>::type>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VP>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVP(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP)},
            create_process_string<Ah, hh, VP>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZ>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVZ(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ)},
            create_process_string<Ah, hh, VZ>({gI1},{gO1},{}));

      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<hh>(std::array<int, 1> {gO1}) + context.physical_mass
            <VZp>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_hhVZp(dec_model.get(), gI1, gO1),
            {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::hh, gO1),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZp)},
            create_process_string<Ah, hh, VZp>({gI1},{gO1},{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<typename conj<Hpm>::type>(std::array<int, 1> {gO1}) +
            context.physical_mass<VWm>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_conjHpmVWm(dec_model.get(), gI1,
            gO1), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Hpm, gO1)
            , UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<Ah, typename conj<Hpm>::type, VWm>({gI1},{gO1
            },{}));

      }

      for (int gO1 = 1; gO1 < 2; ++gO1) {
         if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
            physical_mass<Hpm>(std::array<int, 1> {gO1}) + context.
            physical_mass<typename conj<VWm>::type>(std::array<int, 0> {})) {
            continue;
         }
         decays.set_decay(partial_width_Ah_to_HpmconjVWm(dec_model.get(), gI1,
            gO1), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Hpm, gO1),
            -UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<Ah, Hpm, typename conj<VWm>::type>({gI1},{gO1
            },{}));

      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VG>(std::array<int, 0> {}) + context.physical_mass<VG>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VGVG(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VG), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VG)}, create_process_string<
            Ah, VG, VG>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VP>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVP(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VP)}, create_process_string<
            Ah, VP, VP>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVZ(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZ)}, create_process_string<
            Ah, VP, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VP>(std::array<int, 0> {}) + context.physical_mass<VZp>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VPVZp(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VP), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZp)}, create_process_string<
            Ah, VP, VZp>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VZ>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VZVZ(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZ)}, create_process_string<
            Ah, VZ, VZ>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZ>(std::array<int, 0> {}) + context.physical_mass<VZp>(
         std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VZVZp(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZ), UMSSM_info::
            get_pdg_code_for_particle(UMSSM_info::VZp)}, create_process_string<
            Ah, VZ, VZp>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<VZp>(std::array<int, 0> {}) + context.physical_mass<VZp>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_VZpVZp(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VZp), UMSSM_info
            ::get_pdg_code_for_particle(UMSSM_info::VZp)},
            create_process_string<Ah, VZp, VZp>({gI1},{},{}));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<typename conj<VWm>::type>(std::array<int, 0> {}) +
         context.physical_mass<VWm>(std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_conjVWmVWm(dec_model.get(), gI1),
            {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm),
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::VWm)},
            create_process_string<Ah, typename conj<VWm>::type, VWm>({gI1},{},{
            }));
      }

      if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) > context.
         physical_mass<Glu>(std::array<int, 0> {}) + context.physical_mass<Glu>
         (std::array<int, 0> {})) {
         decays.set_decay(partial_width_Ah_to_GluGlu(dec_model.get(), gI1), {
            UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Glu), UMSSM_info
            ::get_pdg_code_for_particle(UMSSM_info::Glu)},
            create_process_string<Ah, Glu, Glu>({gI1},{},{}));
      }

      for (int gO1 = 0; gO1 < 6; ++gO1) {
         for (int gO2 = 0; gO2 < 6; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<Chi>(std::array<int, 1> {gO1}) + context.
               physical_mass<Chi>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_ChiChi(dec_model.get(), gI1,
               gO1, gO2), {UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Chi, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Chi
               , gO2)}, create_process_string<Ah, Chi, Chi>({gI1},{gO1},{gO2}))
               ;

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fv>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fv>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFvFv(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fv, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fv,
               gO2)}, create_process_string<Ah, typename bar<Fv>::type, Fv>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 2; ++gO1) {
         for (int gO2 = 0; gO2 < 2; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Cha>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Cha>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barChaCha(dec_model.get(), gI1
               , gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info
               ::Cha, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Cha, gO2)}, create_process_string<Ah, typename bar<Cha>::type,
               Cha>({gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fe>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fe>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFeFe(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fe, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fe,
               gO2)}, create_process_string<Ah, typename bar<Fe>::type, Fe>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fd>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fd>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFdFd(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fd, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fd,
               gO2)}, create_process_string<Ah, typename bar<Fd>::type, Fd>({
               gI1},{gO1},{gO2}));

         }
      }

      for (int gO1 = 0; gO1 < 3; ++gO1) {
         for (int gO2 = 0; gO2 < 3; ++gO2) {
            if (context.physical_mass<Ah>(std::array<int, 1>{gI1}) < context.
               physical_mass<typename bar<Fu>::type>(std::array<int, 1> {gO1})
               + context.physical_mass<Fu>(std::array<int, 1> {gO2})) {
               continue;
            }
            decays.set_decay(partial_width_Ah_to_barFuFu(dec_model.get(), gI1,
               gO1, gO2), {-UMSSM_info::get_pdg_code_for_particle(UMSSM_info::
               Fu, gO1), UMSSM_info::get_pdg_code_for_particle(UMSSM_info::Fu,
               gO2)}, create_process_string<Ah, typename bar<Fu>::type, Fu>({
               gI1},{gO1},{gO2}));

         }
      }

   }


}

double CLASSNAME::partial_width_hh_to_SdconjSd(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Sd>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sd>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Sd, typename conj<Sd>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_SvconjSv(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Sv>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sv>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Sv, typename conj<Sv>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_SuconjSu(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Su>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Su>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Su, typename conj<Su>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_SeconjSe(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Se>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Se>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Se, typename conj<Se>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhhh(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<hh>::type out_2_indices {{gO2}};

   return get_partial_width<hh, hh, hh>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhAh(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<hh, hh, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhAh(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<Ah>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Ah, Ah>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_HpmconjHpm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Hpm, typename conj<Hpm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVP(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, hh, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVP(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, Ah, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVZ(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, hh, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVZ(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, Ah, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_hhVZp(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<hh, hh, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_AhVZp(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<hh, Ah, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_conjHpmVWm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<hh, typename conj<Hpm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_HpmconjVWm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<VWm>::type>::type out_2_indices {};

   return get_partial_width<hh, Hpm, typename conj<VWm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VGVG(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VG>::type out_1_indices {};
   const typename field_indices<VG>::type out_2_indices {};

   return get_partial_width<hh, VG, VG>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVP(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<hh, VP, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVZ(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, VP, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VPVZp(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<hh, VP, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VZVZ(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<hh, VZ, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VZVZp(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<hh, VZ, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_VZpVZp(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<VZp>::type out_1_indices {};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<hh, VZp, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_conjVWmVWm(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename conj<VWm>::type>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<hh, typename conj<VWm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_GluGlu(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Glu>::type out_1_indices {};
   const typename field_indices<Glu>::type out_2_indices {};

   return get_partial_width<hh, Glu, Glu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_ChiChi(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<Chi>::type out_1_indices {{gO1}};
   const typename field_indices<Chi>::type out_2_indices {{gO2}};

   return get_partial_width<hh, Chi, Chi>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFvFv(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fv>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fv>::type, Fv>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barChaCha(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Cha>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Cha>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Cha>::type, Cha>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFeFe(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fe>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fe>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFdFd(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fd>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fd>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_hh_to_barFuFu(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<hh>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fu>::type out_2_indices {{gO2}};

   return get_partial_width<hh, typename bar<Fu>::type, Fu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_SdconjSu(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Sd>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Su>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, Sd, typename conj<Su>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_SeconjSv(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Se>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sv>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, Se, typename conj<Sv>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_hhVWm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, hh, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_AhVWm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Ah>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, Ah, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_VPVWm(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, VP, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_VZVWm(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, VZ, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_VZpVWm(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<VZp>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Hpm, VZp, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_ChiCha(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<Chi>::type out_1_indices {{gO1}};
   const typename field_indices<Cha>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, Chi, Cha>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_barFvFe(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, typename bar<Fv>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Hpm_to_barFuFd(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Hpm>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<Hpm, typename bar<Fu>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SdconjSd(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Sd>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sd>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Sd, typename conj<Sd>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SvconjSv(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Sv>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Sv>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Sv, typename conj<Sv>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SuconjSu(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Su>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Su>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Su, typename conj<Su>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_SeconjSe(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Se>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Se>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Se, typename conj<Se>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhhh(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<hh>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, hh, hh>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_HpmconjHpm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Hpm, typename conj<Hpm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVP(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, hh, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVZ(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, hh, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_hhVZp(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<hh>::type out_1_indices {{gO1}};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<Ah, hh, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_conjHpmVWm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename conj<Hpm>::type>::type out_1_indices {{gO1}};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Ah, typename conj<Hpm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_HpmconjVWm(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Hpm>::type out_1_indices {{gO1}};
   const typename field_indices<typename conj<VWm>::type>::type out_2_indices {};

   return get_partial_width<Ah, Hpm, typename conj<VWm>::type>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VGVG(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VG>::type out_1_indices {};
   const typename field_indices<VG>::type out_2_indices {};

   return get_partial_width<Ah, VG, VG>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVP(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VP>::type out_2_indices {};

   return get_partial_width<Ah, VP, VP>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVZ(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, VP, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VPVZp(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VP>::type out_1_indices {};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<Ah, VP, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VZVZ(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZ>::type out_2_indices {};

   return get_partial_width<Ah, VZ, VZ>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VZVZp(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VZ>::type out_1_indices {};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<Ah, VZ, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_VZpVZp(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<VZp>::type out_1_indices {};
   const typename field_indices<VZp>::type out_2_indices {};

   return get_partial_width<Ah, VZp, VZp>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_conjVWmVWm(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename conj<VWm>::type>::type out_1_indices {};
   const typename field_indices<VWm>::type out_2_indices {};

   return get_partial_width<Ah, typename conj<VWm>::type, VWm>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_GluGlu(UMSSM_mass_eigenstates_interface* model, int gI1) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Glu>::type out_1_indices {};
   const typename field_indices<Glu>::type out_2_indices {};

   return get_partial_width<Ah, Glu, Glu>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_ChiChi(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<Chi>::type out_1_indices {{gO1}};
   const typename field_indices<Chi>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, Chi, Chi>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFvFv(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fv>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fv>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fv>::type, Fv>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barChaCha(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Cha>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Cha>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Cha>::type, Cha>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFeFe(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fe>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fe>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fe>::type, Fe>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFdFd(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fd>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fd>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fd>::type, Fd>(context, in_indices, out_1_indices, out_2_indices);
}

double CLASSNAME::partial_width_Ah_to_barFuFu(UMSSM_mass_eigenstates_interface* model, int gI1, int gO1, int gO2) const
{
   context_base context {model};
   const typename field_indices<Ah>::type in_indices {{gI1}};
   const typename field_indices<typename bar<Fu>::type>::type out_1_indices {{gO1}};
   const typename field_indices<Fu>::type out_2_indices {{gO2}};

   return get_partial_width<Ah, typename bar<Fu>::type, Fu>(context, in_indices, out_1_indices, out_2_indices);
}


} // namespace flexiblesusy
